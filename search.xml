<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JUC</title>
    <url>/blog.github.io/2021/12/28/JUC/</url>
    <content><![CDATA[<h2 id="java线程基础"><a href="#java线程基础" class="headerlink" title="java线程基础"></a>java线程基础</h2><ul>
<li><p>栈帧图解</p>
<blockquote>
<p>一个线程一个栈</p>
</blockquote>
<p>  <img src="/blog.github.io/2021/12/28/JUC/1.png"></p>
</li>
<li><p>六种线程状态</p>
<p>  new runnable terminated blocked timed_waiting waiting </p>
</li>
<li><p>interrupt()</p>
<p>  打断不是真打断，只是打个标记，打断sleep join wait会抛出异常且标记仍为false，打断正常执行中的线程还需被打断线程同意，标记为true</p>
</li>
<li><p>上下文切换</p>
<p>  上下文切换会造成结果的不可预测（即使简单的++，–也由于jvm指令的存在也会出现该问题），即在临界区发生竞态，即出现线程安全问题，通过加锁解决，一个线程获得锁时即使cpu时间片用完从而想上下文切换到其他线程其他线程也不会获取锁而是继续被堵塞，直到先前线程完成</p>
</li>
<li><p>变量线程安全问题</p>
<ul>
<li><p>成员变量和静态变量</p>
<p>  如果没有共享，则线程安全，如果共享了且只有读则线程安全，否则不安全</p>
</li>
<li><p>局部变量</p>
<p>  局部变量线程安全。但局部变量引用的对象未必</p>
</li>
</ul>
</li>
</ul>
<h2 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h2><ul>
<li><p>对象头</p>
<p>  对象头（ 8 个字节）由 mark word 和 kclass word 组成，数组对象的对象头还多一个 array length </p>
</li>
<li><p>monitor</p>
<p>  每个java对象都可以关联一个 monitor 对象，当给对象加一个 sychronized ( 重量级锁 )，该对象 mark word 设置为指向 monitor 对象</p>
</li>
<li><p>moniter 工作原理</p>
<p>  <img src="/blog.github.io/2021/12/28/JUC/2.png"></p>
</li>
<li><p>偏向锁-轻量级锁-重量级锁</p>
<p>   偏向锁默认开启，第一个线程优先使用，此时第二个线程还没来即偏向第一个线程，当第一个线程解锁完毕，第二个开始使用轻量级锁，如果第三个线程来了发生线程竞争在膨胀为重量级锁。</p>
<p>  没有竞争时撤销偏向锁超过 20 次则重新偏向，且是批量撤销，超过 40 次则不偏向</p>
</li>
</ul>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><p>sleep 和 wait 的线程状态都是 timed_waiting ，但是sleep的其他线程不能获得锁，wait 可以。wait 和 notify 只有获得锁的线程才能调用。</p>
<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park unpark"></a>park unpark</h2><p>类似 wait notify，但可以 unpark 再 park，park 可以不用获取锁</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><ol>
<li>调用 start()，由 new 变为 runable </li>
<li>获得锁以后，调用 wait()，从 runable 变为 waiting</li>
<li>调用 notify() noyifyALl() interrupt() 时，竞争失败由 waiting 变为 blocked，竞争成功由 waiting 变为 runable</li>
<li>sleep(),从 runable 变为 timed_waiting</li>
</ol>
<h2 id="死锁查询"><a href="#死锁查询" class="headerlink" title="死锁查询"></a>死锁查询</h2><p>jps 获得 id，jstack 查看详情或者用 visualVM 或 jconsole</p>
<h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><p>JMM(Java Memory Model)</p>
<blockquote>
<p>原子性（不会受到上下文切换的影响）</p>
<p>可见性（不会受到cpu缓存影响）</p>
<p>有序性（不会受到cpu指令优化的影响）</p>
</blockquote>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>jit 会将主存中的值缓存到工作内存从而导致可见性问题，可将共享变量加 volatile 解决，就是易变变量</p>
<p>synchronized 既可以保证原子性又可以保证可见性，但 synchronized 是重量级操作，性能低，volatile 不能保证原子性，因此 volatile 仅适合用在一个线程写多个线程读的情况下，synchronized 不能禁止重排序</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>volatile 写屏障会保证屏障之前的代码排在屏障之后</p>
<p>volatile 读屏障会保证屏障之后的代码排在屏障之前</p>
<h2 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h2><blockquote>
<p>线程数少于cpu核心数用 cas 保证线程安全，cas 基于「乐观锁」，synchronized 基于悲观锁</p>
</blockquote>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>AtomicBoolean AtomicInteger AtomicLong</p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>AtomicReference、AtomicReference「添加版本号解决ABA问题」</p>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>AtomicIntegerArray AtomicLongArray AtomicReferenceArray</p>
<h3 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h3><p>AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</p>
<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><blockquote>
<p>包装类、String、BigDecimal等。单个方法线程安全不代表多个方法组合线程安全</p>
</blockquote>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote>
<p>数据库连接池、包装类的cache等</p>
</blockquote>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><blockquote>
<p>线程安全，因为没有成员变量，例如servlet不设置成员变量</p>
</blockquote>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>lock</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>archLinux 安装</title>
    <url>/blog.github.io/2021/12/28/archLinux-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文采用efi分区，因为厌烦了grub故换systemd-boot，桌面为bspwm，硬件为Intel cpu和amd gpu</p>
<h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><h3 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h3><p>ls /sys/firmware/efi/efivars</p>
<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>iwctl </p>
<h3 id="检查是否联通"><a href="#检查是否联通" class="headerlink" title="检查是否联通"></a>检查是否联通</h3><p>ping -c 3 archlinux.org</p>
<h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><p>timedatectl set-ntp true </p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><pre><code>1. fidsk /dev/sda
2. g新建gpt分区表
3. n新建分区 ,类型序号开头都回车结尾定义空间大小，然后t改成efi
4. p查看完成的分区表，w保存退出
5. 自改分区如下
    1. sda1 +512M EFI
    2. sda2 +50G 
    3. sda3 余下
</code></pre>
<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><pre><code>1.  mkfs.fat -F32 /dev/sda1
2.  mkfs.ext4 /dev/sda2
3.  mkfs.ext4 /dev/sda3
</code></pre>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><pre><code>1.  mount /dev/sda2  /mnt
2.  mkdir -p /mnt/boot &amp; mount /dev/sda1  /mnt/boot
3.  mkdir -p /mnt/home &amp; mount /dev/sda3  /mnt/home
</code></pre>
<h3 id="安装基本操作系统"><a href="#安装基本操作系统" class="headerlink" title="安装基本操作系统"></a>安装基本操作系统</h3><p>pacstrap /mnt base linux linux-firmware vim iwd </p>
<h3 id="配置挂载信息"><a href="#配置挂载信息" class="headerlink" title="配置挂载信息"></a>配置挂载信息</h3><p>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</p>
<h3 id="切换到安装到系统"><a href="#切换到安装到系统" class="headerlink" title="切换到安装到系统"></a>切换到安装到系统</h3><p>arch-chroot /mnt </p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>1. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
2. hwclock --systohc
</code></pre>
<h3 id="本地化编码"><a href="#本地化编码" class="headerlink" title="本地化编码"></a>本地化编码</h3><pre><code>1.  vim /etc/locale.gen，反注释zh_CN.UTF-8 UTF-8和us_EN.UTF-8
2.  locale-gen
3.  vim /etc/locale.conf 加入 LANG=en_US.UTF-8
</code></pre>
<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><pre><code>1. echo “shaka-arch” &gt;&gt; /etc/hostname
2. /etc/hosts 
    127.0.0.1   localhost
    ::1             localhost
    127.0.1.1   shaka-arch.localdomain  shaka-arch
</code></pre>
<h3 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h3><pre><code>1. passwd
2. useradd -m xxx 然后passwd xxx
</code></pre>
<h3 id="Intel微码"><a href="#Intel微码" class="headerlink" title="Intel微码"></a>Intel微码</h3><p>pacman -S intel-ucode</p>
<h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><pre><code>1.  bootctl --path=/boot$esp install
2.  vim /boot/loader/loader.conf （没有下面的序号）
    1. default arch #默认引导的系统，注意这里的 arch 对应的是 arch.conf
    2. timeout 1    #在引导界面停留的时间，如果你想引导不止一个系统，不应将这一项设置成0
    3. editor    0    #这将会禁用编辑内和参数的功能，默认是开启的，如果你的计算机可能被他人使用，将该功能关闭是推荐的选择
3. vim /boot/loader/entries/arch.conf
    1. title Arch Linux               #这是启动选项的名称，将会出现在引导界面
    2. linux   /vmlinuz-linux         #压缩的可引导内核，用于系统启动
    3. initrd  /intel-ucode.img       #由芯片制造商提供的对 CPU 微码的稳定性和安全性更新，按照 Arch wiki 的说法它应当是&#39; first initrd in the bootloader config file&#39;
    4. initrd  /initramfs-linux.img   #为内核提供的一个临时的文件系统
    5. options root=/dev/sdap2 rw     #/root 挂载的位置，可以由 LABEL, PARTUUID 或者 UUID识别，此处使用了块设备的路径
</code></pre>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>1.  systemctl enable systemd-networkd
2.  systemctl enable systemd-resolved
3.  systemctl enable systemd-timesyncd
4.  systemctl enable iwd
</code></pre>
<h3 id="加入sudoers"><a href="#加入sudoers" class="headerlink" title="加入sudoers"></a>加入sudoers</h3><p>pacman -S sudo 然后 EDITOR=vim visudo </p>
<h3 id="复制网络配置到新系统"><a href="#复制网络配置到新系统" class="headerlink" title="复制网络配置到新系统"></a>复制网络配置到新系统</h3><p>cp /etc/systemd/network/* /mnt/etc/systemd/network/ </p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>exit 然后 umount -R /mnt 接着reboot重启机器</p>
<h2 id="桌面bspwm"><a href="#桌面bspwm" class="headerlink" title="桌面bspwm"></a>桌面bspwm</h2><pre><code>1. sudo pacman -S xf86-video-amdgpu alsa alsa-utils显卡声卡驱动
2. alsamixer 调节音量
3. sudo pacman -S xorg 图形服务
4. sudo pacman -S bspwm sxhkd feh 
5. yay -S polybar 状态栏
6. 安装完成后需要在$HOME/.xinitrc中添加exec bspwm，然后通过startx即可启动。
7. 在家目录下分别新建文件夹 .config/bspwm   .config/sxhkd   .config/polybar用于存放对应配置，分别是bspwm，快捷键和polybar的基本配置文件，初始配置可从/usr/share/doc中获取
8. alacritty 终端模拟器 ranger 文件管理器 sxiv 图片浏览 rofi程序查找
9. 壁纸feh --bg-fill --randomize --recursive IMAGES_DIR_PATH 加入到bspwmrc配置文件
10. wqy-microhei中文字体
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>archLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/blog.github.io/2022/03/23/jvm/</url>
    <content><![CDATA[<blockquote>
<p>jvm 笔记</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类的加载分为三个阶段，即加载、链接和初始化</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>引导类加载器</p>
<p> c/c++ 语言编写，无法获取，用于加载java的核心类库</p>
</li>
<li><p>扩展类加载器</p>
<p> 加载 java.ext.dirs 系统路径所指定的类库，自己的应用放在其中也可以由扩展类加载器加载</p>
</li>
<li><p>系统类加载器</p>
<p> 加载自己的 java 应用程序</p>
</li>
<li><p>自定义类加载器</p>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>java虚拟机对 class 文件的加载是按需加载，收到加载请求先由父加载器加载，加载失败则由子加载器加载</p>
<p>判断 Class 是否为同一个，则需要全限定类名和类加载器都相同</p>
<p>优势</p>
<ol>
<li><p>防止重复加载</p>
</li>
<li><p>防止核心 API 被篡改</p>
</li>
</ol>
<h2 id="内存与垃圾回收篇"><a href="#内存与垃圾回收篇" class="headerlink" title="内存与垃圾回收篇"></a>内存与垃圾回收篇</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>图示</p>
<p><img src="/blog.github.io/2022/03/23/jvm/1.png"></p>
<p>上图红色的共享，灰色的每个线程独有</p>
<h3 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h3><p>用来存储 java 指令的地址，运行速度快且不会内存溢出</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>运行速度仅次于 PC 寄存器，基本单位为栈帧，设置栈大小 Xss</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>内部结构：<code>局部变量表</code>、<code>操作数栈</code>、动态链接、方法返回地址、一些附加信息</p>
<ol>
<li><p>局部变量表</p>
<p> 基本单位为 slot，存放基本数据类型和引用，long 和 double 占两个 slot，非静态方法的第一个变量为 this，其他按声明顺序排序，且一旦销毁可以重用</p>
<p> 类变量在链接的 prepare 阶段默认赋值，在初始化阶段显式赋值和静态代码块赋值</p>
<p> 实例变量随着对象的创建在堆空间赋值</p>
<p> 局部变量必须显式赋值</p>
</li>
<li><p>操作数栈</p>
<p> 根据字节码指令往操作数栈中存取数据，主要用来保存计算过程中的中间结果，同时作为计算过程变量的临时保存空间，刚有栈帧时操作数栈是空的，但最大深度在编译器就定义好了</p>
</li>
</ol>
<ol start="3">
<li><p>动态链接</p>
<p> 指向运行时常量池的方法的引用</p>
</li>
<li><p>方法的调用</p>
<p> 早起绑定（编译期确定）和晚期绑定（运行期确定/多态）</p>
<p> 非虚方法：静态方法、私有方法、final 方法、实例构造器、父类方法</p>
<p> 虚方法：其他方法</p>
<p> 在类加载的链接阶段为了提高性能会创建一个虚方法表，已经重写的用自己的，没重写的记录下来不必一层层向上找</p>
</li>
<li><p>方法返回地址</p>
<p> 存放调用该方法的 PC 寄存器的值</p>
</li>
<li><p>栈帧附加信息</p>
</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>有时 java 应用需要与外部环境交互，这是本地方法存在的主要原因，本地方法栈并非所有虚拟机都有</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一个进程一个 jvm 实例，一个 jvm 实例一个运行时数据区，一个堆区，一个进程多个线程，一个线程一个栈、一个 pc 寄存器、一个本地方法栈，堆(除了TLAB)和方法区多个线程共享，堆是 GC 的重点</p>
<h3 id="堆的细分"><a href="#堆的细分" class="headerlink" title="堆的细分"></a>堆的细分</h3><p>jdk7 及以前分为新生代、老年代和永久代（逻辑上）</p>
<p>jdk8 以后分为新生代、老年代和元空间（逻辑上）</p>
<p>新生代分为伊甸园区和幸存者区</p>
<p>Xms 设置初始（新生代 + 老年代）大小， Xmx 设置最大（新生代 + 老年代）值，-XX:NewRatio 配置新生代与老年代占比，-XX: SurvivorRatio 配置伊甸园区与幸存者区占比</p>
<p>对象不一定创建在堆中，可以开启逃逸分析开启栈上分配</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><ul>
<li><p>新对象优先放伊甸园区</p>
</li>
<li><p>当伊甸园区空间满了又需要放入新对象，则进行 young GC/Minor GC，将不再需要的垃圾回收，再把新对象放入伊甸园区，将剩余的放入幸存者区</p>
</li>
<li><p>当伊甸园区再次满了，则再次垃圾回收将没回收的对象放入另一块幸存者区，同时将原来的幸存者区的对象也放入这块幸存者区</p>
</li>
<li><p>当幸存者区对象的年龄达到阈值值提升进老年代，默认15</p>
</li>
<li><p>当伊甸园区满了才会 young GC/Minor GC，幸存者区满了不会触发 young GC/Minor GC，但幸存者区的无用对象在 young GC/Minor GC  的时候也会被回收</p>
</li>
<li><p>大部分对象朝生夕死，在 young GC/Minor GC 就被回收掉了</p>
</li>
<li><p>如果新对象新生代 young GC 后还放不下则直接准备放进老年代，如果老年代放不下进行 Major GC，Major GC 之后放得下放进老年代，放不下则 OOM</p>
</li>
<li><p>当 young GC 时幸存者区放不下伊甸园区来的对象则放进老年代</p>
</li>
<li><p>young GC 会清空伊甸园区</p>
</li>
<li><p>TLAB 是在伊甸园区为每个线程创建的一小块区域，为线程私有，空间很小，无线程安全问题，对象优先分配在 TLAB 空间</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于储存已经加载的类信息、运行时常量池、静态变量、JIT 代码缓存等</p>
<p>Hotspot 方法区的变化：</p>
<p><img src="/blog.github.io/2022/03/23/jvm/2.png"></p>
<hr>
<p>为什么去永久代？</p>
<ol>
<li><p>永久代大小很难确定，小了容易 Full GC 造成 STW，大了造成浪费</p>
</li>
<li><p>永久代调优困难</p>
</li>
</ol>
<hr>
<p>为什么 StringTable 换位置？</p>
<p>放在堆里回收效率更高</p>
<hr>
<p>方法区的垃圾回收主要针对类的卸载和常量池，不同虚拟机不一定都有方法区的回收</p>
<h3 id="对象的实例化、内存布局及访问定位"><a href="#对象的实例化、内存布局及访问定位" class="headerlink" title="对象的实例化、内存布局及访问定位"></a>对象的实例化、内存布局及访问定位</h3><p>对象实例化的几种方式：new、反射、反序列化、clone、第三方库</p>
<p>对象的创建步骤：</p>
<ol>
<li><p>对象对应的类是否加载、链接、初始化</p>
</li>
<li><p>为对象分配内存</p>
</li>
<li><p>处理并发安全问题</p>
</li>
<li><p>初始化分配到的空间/默认初始化</p>
</li>
<li><p>设置对象头</p>
</li>
<li><p>执行 Init 方法的初始化</p>
</li>
</ol>
<p>对象的内存布局：</p>
<ol>
<li><p>对象头</p>
<ul>
<li><p>运行时元数据</p>
</li>
<li><p>类型指针</p>
</li>
<li><p>如果是数组，还得记录数组长度</p>
</li>
</ul>
</li>
<li><p>实例数据</p>
</li>
<li><p>对齐填充</p>
</li>
</ol>
<p>对象的访问主要有句柄访问和直接访问</p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>解释器：响应速度快</p>
<p>JIT编译器：效率高</p>
<p>jvm 启动时解释器首先发挥作用，无需等待编译器全部编译完成再执行，省却不必要的编译时间，随着时间推移，编译器发挥作用，越来越多的代码被编译成本地代码，获得更高的执行效率</p>
<p>一个被多次调用的方法，或者一个方法体内部循环次数较多的循环体被称作「热点代码」，可以通过 JIT 编译为本地代码，由于编译发生在方法执行过程中，因此被称为栈上替换(OSR)</p>
<p>HotSpot 采用方法调用计数器和回边计数器判定热点代码</p>
<p>方法调用计数器 Server 模式(64 位系统默认)下阈值为 10000，Client 模式下为 1500，如果超过一定时间仍不足以达到阈值，则会进入半衰期，半衰回收发生在 GC 时</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JDK1.8 以前用 char 数组，9 以后用 byte 数组，因为大部分情况下都是拉丁字符，为了省空间改为 byte，为了兼容中文等字符，加上编码标记</p>
<p>String 不可变</p>
<p>字符串常量池不会存储相同的字符串，是一个固定大小的 HashTable</p>
<p>拼接操作：</p>
<pre><code>字符串常量与字符串常量拼接结果在字符串常量池，原因是编译期优化

出现变量相当于堆中 new String()

intern() 判断常量池中是否存在，存在返回地址，否则加载一份并返回地址
</code></pre>
<h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><p>垃圾回收针对<code>堆</code>和方法区，程序计数器没有 GC 没有溢出，栈和本地方法栈没有 GC 有 StackOverFlow</p>
<h4 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h4><p><code>引用计数算法</code></p>
<p>使用引用计数器</p>
<p>优点：简单便于标识，效率比较高，回收没有延迟</p>
<p>缺点: 增加储存空间和计数开销，最糟糕的是无法处理循环引用，因此 Java 不用该算法</p>
<p><code>可达性分析算法</code></p>
<p>直接或间接连接 GC Roots</p>
<p>GC Roots:</p>
<ul>
<li><p>栈引用的对象</p>
</li>
<li><p>本地方法引用的对象</p>
</li>
<li><p>静态属性、常量引用的对象</p>
</li>
<li><p>被同步锁持有的对象</p>
</li>
<li><p>Java 虚拟机内部引用</p>
</li>
</ul>
<h4 id="清除算法"><a href="#清除算法" class="headerlink" title="清除算法"></a>清除算法</h4><p><code>标记清除算法</code></p>
<p>从根对象标记所有可达对象，然后线性遍历堆中所有对象删除不可达对象</p>
<p>缺点：效率低、碎片化</p>
<p><code>复制算法</code></p>
<p>使用两块空间，每次只使用一块，然后把可达对象复制到另一块空间，需要复制的对象越少越好，例如新生代朝生夕死</p>
<p>优点：高效、无碎片化</p>
<p>缺点：需要两倍空间、需要维护引用关系</p>
<p><code>标记压缩算法</code></p>
<p>标记所有被引用对象，然后移动到内存的一端清除其他</p>
<p>优点：消除了标记清除算法的碎片化和复制算法的 2 倍空间浪费</p>
<p>缺点：效率不如复制算法，移动时需要调整引用位置</p>
<p><code>分代收集算法</code></p>
<p>新生代对象生命周期短，存活率低、回收频繁，用复制算法，空间浪费用两块幸存者区补偿，老年代空间大、对象大、存活率高、生命周期长回收频率又低适合标记清除和标记压缩的混合实现</p>
<h3 id="垃圾回收相关"><a href="#垃圾回收相关" class="headerlink" title="垃圾回收相关"></a>垃圾回收相关</h3><p>System.gc() 不一定马上调用垃圾回收</p>
<p>严格来说只有对象不被用到又无法 GC 才算内存泄露，内存泄露有可能导致内存溢出</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>强引用</p>
<p>传统的引用，只要引用关系在就不会被回收，强引用是造成内存泄露的主要原因之一</p>
<p>软引用</p>
<p>在内存溢出之前列入回收范围之内进行第二次回收，如果回收完还是不够则内存溢出，即内存不够则回收，典型应用场景比如高速缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftReference = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="string">&quot;shaka&quot;</span>, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<p>弱引用</p>
<p>只能生存到下一次垃圾回收之前，当 GC 工作时无论是否引用都会被回收，即发现即回收</p>
<p>虚引用</p>
<p>对其生存没影响也不能通过引用获得对象，唯一目的是回收时收到一个系统通知</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3</title>
    <url>/blog.github.io/2022/02/21/vue3/</url>
    <content><![CDATA[<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p><a href="https://cn.vitejs.dev/">新一代构建工具</a></p>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>组合式api,数据、方法等都要配置在setup函数中，并且必须返回，响应式基本数据类型、对象类型用ref，对象类型用reactive</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = ref(<span class="string">&#x27;shaka&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tom = reactive(&#123;<span class="attr">uname</span>:<span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name.value);</span><br><span class="line">    tom.age = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(tom)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    say,</span><br><span class="line">    tom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>setup仅在beforeCreated执行一次，且this为undefined</p>
<p>props父组件向子组件传参,context上下文对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.p1);</span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> lastName = <span class="string">&#x27;jerry&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      firstName,</span><br><span class="line">      lastName,</span><br><span class="line">      fullName,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监视</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = ref(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      a.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    watch(a,<span class="function">(<span class="params">newValue,oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a的值变了&#x27;</span>,newValue,oldValue)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      add,</span><br><span class="line">      a</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
</search>
