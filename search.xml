<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JUC 并发编程</title>
    <url>/blog.github.io/2022/04/06/JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>上下文切换原因</code></p>
<ol>
<li><p>时间片用完</p>
</li>
<li><p>垃圾回收</p>
</li>
<li><p>有更高线程优先级需要运行</p>
</li>
<li><p>线程自己调用了 sleep yiled join park lock synchronized 方法</p>
</li>
</ol>
<p>当发生上下文切换时操作系统会保存当前线程状态（PC 寄存器、栈帧信息）并恢复另一个，频繁切换上下文会影响性能。</p>
<p><code>sleep()</code></p>
<ol>
<li><p>调用 sleep 线程会让线程进入 TIMED_WAITING</p>
</li>
<li><p>其他线程调用 interrupt() 方法会打断正在睡的线程，打断的是睡眠，抛出 InterruptedException 异常</p>
</li>
<li><p>睡眠结束后的线程未必会立即执行</p>
</li>
<li><p>建议使用 TimeUnit 的 sleep，可读性更好</p>
</li>
</ol>
<p><code>yiled()</code></p>
<p>让线程从 Running 变成 Runnable 状态，具体实现依赖操作系统的任务调度，但还是有机会继续执行，而 sleep() 的线程处于 TIMED_WAITING，并不会调度到 sleep() 的线程</p>
<p><code>join()</code></p>
<p>等待某个线程运行结束，要等待的线程进入 WAITING</p>
<p><code>interrupt()</code></p>
<p>打断 join wait sleep 的线程之后的被打断线程的打断标记为 false，而正常运行的线程被打断的话只会把打断标记设为 true，相当于只是告知了有人要打断我，但结束与否还得看我自己</p>
<p>interrupt() 的应用：两阶段终止模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 重新设置打断标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打断 park()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">// 打断标记为 true 的线程只能 park 一次，要想再 park 只好再清除打断标记</span></span><br><span class="line">            System.out.println(<span class="string">&quot;打断标记为&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            System.out.println(<span class="string">&quot;打断标记为&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>非守护线程结束了守护线程就算没执行完也会强制结束，垃圾回收器就是一种守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="comment">// 把 t1 设置为守护线程，这样一旦 main 线程结束则强制结束 t1 线程</span></span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java-线程的六种状态源码"><a href="#Java-线程的六种状态源码" class="headerlink" title="Java 线程的六种状态源码"></a>Java 线程的六种状态源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &#123;<span class="doctag">@code</span> Object.wait()&#125;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> Object.notify()&#125; or &#123;<span class="doctag">@code</span> Object.notifyAll()&#125; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &#123;<span class="doctag">@code</span> Thread.join()&#125;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h3><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>临界区：一块代码去如果存在堆共享资源的对线程读写操作，则该代码块为临界区。</p>
<p>竞态：多个线程在临界区执行，由于代码执行序列的不同导致结果不可预测，则称之为发生了竞态</p>
<p><code>竞态解决方案：</code></p>
<ol>
<li><p>阻塞式：synchronized、Lock</p>
</li>
<li><p>非阻塞式：原子变量</p>
</li>
</ol>
<p><code>线程安全分析</code></p>
<ol>
<li><p>成员变量、静态变量，如果没有共享则线程安全，共享了只有读操作也线程安全，读写都有则线程不安全</p>
</li>
<li><p>局部变量，局部变量线程安全，但其引用的对象未必安全，如果局部变量引用的对象没有逃离方法作用范围则线程安全，否则需要考虑线程安全问题</p>
</li>
</ol>
<p>常用的 spring boot 增删查改方法是单例的，但是要么不涉及成员变量要么不涉及写操作，因此是线程安全的</p>
<p><code>Monitor</code></p>
<p>由 JVM 知道对象头（ 8 个字节）由 mark word 和 kclass word 组成，数组对象的对象头还多一个 array length, mark word 遇到 synchronized 会指向一个由操作系统提供的 Monitor 对象，Monitor 对象有 owner 属性指向该锁属于哪个线程，再来的线程会先自旋几次（万一锁被释放，自旋适合多核 CPU ）再进入 Monitor 对象的 entryList 队列中等待并且线程状态变为 Blocked。一个锁对应一个 Monitor，不加 synchronized 就不关联 Monitor</p>
<p><code>synchronized 优化</code></p>
<p>对象头格式：<br><img src="/blog.github.io/2022/04/06/JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1.png"></p>
<p>轻量级锁</p>
<p>偏向锁</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/blog.github.io/2021/12/28/JUC/</url>
    <content><![CDATA[<h2 id="java线程基础"><a href="#java线程基础" class="headerlink" title="java线程基础"></a>java线程基础</h2><ul>
<li><p>六种线程状态</p>
<p>  new runnable terminated blocked timed_waiting waiting </p>
</li>
<li><p>interrupt()</p>
<p>  打断不是真打断，只是打个标记，打断sleep join wait会抛出异常且标记仍为false，打断正常执行中的线程还需被打断线程同意，标记为true</p>
</li>
<li><p>上下文切换</p>
<p>  上下文切换会造成结果的不可预测（即使简单的++，–也由于jvm指令的存在也会出现该问题），即在临界区发生竞态，即出现线程安全问题，通过加锁解决，一个线程获得锁时即使cpu时间片用完从而想上下文切换到其他线程其他线程也不会获取锁而是继续被堵塞，直到先前线程完成</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>变量线程安全问题</p>
<ul>
<li><p>成员变量和静态变量</p>
<p>  如果没有共享，则线程安全，如果共享了且只有读则线程安全，否则不安全</p>
</li>
<li><p>局部变量</p>
<p>  局部变量线程安全。但局部变量引用的对象未必</p>
</li>
</ul>
</li>
</ul>
<h2 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h2><ul>
<li><p>对象头</p>
<p>  对象头（ 8 个字节）由 mark word 和 kclass word 组成，数组对象的对象头还多一个 array length </p>
</li>
<li><p>monitor</p>
<p>  每个java对象都可以关联一个 monitor 对象，当给对象加一个 sychronized ( 重量级锁 )，该对象 mark word 设置为指向 monitor 对象</p>
</li>
<li><p>moniter 工作原理</p>
<p>  <img src="/blog.github.io/2021/12/28/JUC/2.png"></p>
</li>
<li><p>偏向锁-轻量级锁-重量级锁</p>
<p>   偏向锁默认开启，第一个线程优先使用，此时第二个线程还没来即偏向第一个线程，当第一个线程解锁完毕，第二个开始使用轻量级锁，如果第三个线程来了发生线程竞争在膨胀为重量级锁。</p>
<p>  没有竞争时撤销偏向锁超过 20 次则重新偏向，且是批量撤销，超过 40 次则不偏向</p>
</li>
</ul>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><p>sleep 和 wait 的线程状态都是 timed_waiting ，但是sleep的其他线程不能获得锁，wait 可以。wait 和 notify 只有获得锁的线程才能调用。</p>
<h2 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park unpark"></a>park unpark</h2><p>类似 wait notify，但可以 unpark 再 park，park 可以不用获取锁</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><ol>
<li>调用 start()，由 new 变为 runable </li>
<li>获得锁以后，调用 wait()，从 runable 变为 waiting</li>
<li>调用 notify() noyifyALl() interrupt() 时，竞争失败由 waiting 变为 blocked，竞争成功由 waiting 变为 runable</li>
<li>sleep(),从 runable 变为 timed_waiting</li>
</ol>
<h2 id="死锁查询"><a href="#死锁查询" class="headerlink" title="死锁查询"></a>死锁查询</h2><p>jps 获得 id，jstack 查看详情或者用 visualVM 或 jconsole</p>
<h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><p>JMM(Java Memory Model)</p>
<blockquote>
<p>原子性（不会受到上下文切换的影响）</p>
<p>可见性（不会受到cpu缓存影响）</p>
<p>有序性（不会受到cpu指令优化的影响）</p>
</blockquote>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>jit 会将主存中的值缓存到工作内存从而导致可见性问题，可将共享变量加 volatile 解决，就是易变变量</p>
<p>synchronized 既可以保证原子性又可以保证可见性，但 synchronized 是重量级操作，性能低，volatile 不能保证原子性，因此 volatile 仅适合用在一个线程写多个线程读的情况下，synchronized 不能禁止重排序</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>volatile 写屏障会保证屏障之前的代码排在屏障之后</p>
<p>volatile 读屏障会保证屏障之后的代码排在屏障之前</p>
<h2 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h2><blockquote>
<p>线程数少于cpu核心数用 cas 保证线程安全，cas 基于「乐观锁」，synchronized 基于悲观锁</p>
</blockquote>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>AtomicBoolean AtomicInteger AtomicLong</p>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>AtomicReference、AtomicReference「添加版本号解决ABA问题」</p>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>AtomicIntegerArray AtomicLongArray AtomicReferenceArray</p>
<h3 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h3><p>AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</p>
<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><blockquote>
<p>包装类、String、BigDecimal等。单个方法线程安全不代表多个方法组合线程安全</p>
</blockquote>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote>
<p>数据库连接池、包装类的cache等</p>
</blockquote>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><blockquote>
<p>线程安全，因为没有成员变量，例如servlet不设置成员变量</p>
</blockquote>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>lock</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 字节码与类的加载</title>
    <url>/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p><code>魔数</code></p>
<p>标识合法的 class 文件，4 个字节</p>
<p><code>版本号</code></p>
<p>4 个字节，主版本和副版本，从 45 开始，每个版本加 1，高版本的虚拟机可以执行低版本编译生成的 class 文件，反之不行</p>
<p><code>常量池</code></p>
<p>构成：常量池计数器( 1 个字节 )和常量池表( N 个字节 )</p>
<p>常量池表构成：字面量和符号引用</p>
<p><code>访问标识</code></p>
<p><code>类索引</code></p>
<p><code>父类索引</code></p>
<p><code>接口索引集合</code></p>
<p><code>字段表集合</code></p>
<p>构成：字段计数器、字段表</p>
<p><code>方法表集合</code></p>
<p>构成：方法计数器、方法表</p>
<p><code>属性集合</code></p>
<p>构成：属性计数器、属性表</p>
<h3 id="javac-与-javap"><a href="#javac-与-javap" class="headerlink" title="javac 与 javap"></a>javac 与 javap</h3><p>javac -g 与没有 -g 参数相比多了局部变量表等信息，idea 和 eclipse 默认有 -g 参数</p>
<p>javap -v 反汇编，详细，加上 -p 显示私有</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>指令由操作码和操作数(很多没有)构成</p>
<p>局部变量表、操作数栈以槽位为单位，byte short int boolean floot char 占4个字节，一个槽位，其中byte short char 存储时自动转为 int 以占满 4 个字节，double long 占 8 个字节，2 个槽位，引用类型也占一个槽位</p>
<p><code>压栈指令</code></p>
<p>从局部变量表压入操作数栈，load </p>
<p><code>常量入栈指令</code></p>
<p>const: int long double float 和引用类型使用</p>
<p>push: byte short 使用</p>
<p>dc: 万能型</p>
<p><code>出栈装入局部变量表指令</code></p>
<p>store</p>
<p><code>算术指令</code></p>
<p><img src="/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/1.png"></p>
<p><code>类型转换指令</code></p>
<p>宽化类型转换/自动类型转换【简化: int ——&gt; long ——&gt; float ——&gt; double 会发生精度损失】</p>
<ul>
<li><p>int 到 其他: i2l i2f i2d</p>
</li>
<li><p>long 到其他: l2f l2d</p>
</li>
<li><p>float 到其他: f2d</p>
</li>
<li><p>byte short 转换为较大范围类型看作是 int</p>
</li>
</ul>
<p>窄化类型转换【精度损失更大】</p>
<ul>
<li><p>int 到其他: i2s i2b i2c</p>
</li>
<li><p>long 到 int: l2i</p>
</li>
<li><p>float 到其他: f2i f2l</p>
</li>
<li><p>double 到其他: d2f d2l d2i</p>
</li>
</ul>
<p><code>对象和数组的创建指令</code></p>
<p>对象创建指令：new</p>
<p>数组的创建指令：newarray（基本数据类型）anewarray（引用数据类型）multianewarray（多维数组）</p>
<p><code>字段访问指令</code></p>
<p>类字段：getstatic putstatic</p>
<p>实例字段：gefield putfield</p>
<p><code>数组操作指令</code></p>
<p>aload（压栈） astore（赋值） arraylength（数组长度）</p>
<p><code>类型检查指令</code></p>
<p>instanceof checkcast</p>
<p><code>方法调用指令</code></p>
<p>invokevirtual：虚方法分派，支持多态</p>
<p>invokeinterface：调用接口方法</p>
<p>invokespecial：构造器、私有和父类方法</p>
<p>invokestatic：类方法</p>
<p><code>方法返回指令</code></p>
<p>return</p>
<p><code>操作数栈管理指令</code></p>
<p>弹出：pop 复制：dup 交换数值：swap</p>
<p><code>比较指令</code></p>
<p>dcmpg dcmpl fcmpg fcmpl lcmp</p>
<p>double float 有两套是因为 Nan 值处理方式不同，例如 fcmpg 压入 1，fcmpl 压入 -1</p>
<p><code>条件跳转指令</code></p>
<p>ifeq iflt ifle ifne ifgt ifge （用来比较 long float 和 double）</p>
<p><code>比较条件跳转指令</code></p>
<p>if_icmpeq if_icmpne if_icmplt if_icmpgt if_icmpge if_icmpeq if_acmpeq if_acmpne</p>
<p><code>多条件跳转指令</code></p>
<p>tablestitch（连续的值） lookupstitch（不连续但会进行排序）</p>
<p><code>无条件跳转指令</code></p>
<p>goto</p>
<p><code>抛出异常指令</code></p>
<p>athrow 手动抛出</p>
<p><code>异常处理指令</code></p>
<p>处理异常是由异常表实现的，并没有 try catch 体现</p>
<p><code>同步指令</code></p>
<p>方法级的同步和普通方法指令没区别，当通过访问标志判断某方法是同步方法会自动在方法调用前加锁</p>
<p>同步代码块：monitorenter monitorexit，通过异常表维护释的放锁，如果监视器计数器为 0 则进入，为 1 则判断监视器线程是否为自己，为自己进入，否则等待</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>过程一：加载阶段</code></p>
<ul>
<li><p>获取二进制流的方式</p>
<ul>
<li><p>通过文件系统读入</p>
</li>
<li><p>通过 jar 等数据包提取文件</p>
</li>
<li><p>通过网络加载</p>
</li>
<li><p>在运行时动态生成</p>
</li>
</ul>
</li>
<li><p>类模版和 Class 的位置</p>
<p>  类模版在方法区，Class 实例在堆区</p>
</li>
<li><p>数组类的加载</p>
<p>  数组类并非由类加载器负责创建，而是由 JVM 在运行时根据需要直接创建的</p>
</li>
</ul>
<p><code>过程二：链接阶段</code></p>
<ol>
<li><p>验证</p>
<ul>
<li><p>格式检查（检查魔数、版本和长度，和加载同时进行）</p>
</li>
<li><p>语义检查</p>
</li>
<li><p>字节码验证</p>
</li>
<li><p>符号引用验证</p>
</li>
</ul>
</li>
<li><p>准备</p>
</li>
</ol>
<p>为类中的静态变量分配内存并赋默认值，但并不包括常量，常量在编译时就已经分配，若以字符串字面量方式为常量赋值则也在此阶段显式赋值，在这个阶段并不会有代码的执行</p>
<ol start="3">
<li>解析</li>
</ol>
<p>将类、接口、字段、方法等符号引用转为直接引用，以方法为例，通过解析符号引用可以转为目标方法在方法表中的位置</p>
<p><code>过程三：初始化阶段</code></p>
<p>为静态变量赋予正确的值，到了此阶段才会真正执行代码（静态代码块），&lt;clinit&gt; 方法就是由静态变量的显示赋值和静态代码块构成，此方法由 JVM 自动调用，并且总是先调用父类的 &lt;clinit&gt;</p>
<p>没有静态变量的显式赋值和静态代码块就没有 &lt;clinit&gt;，</p>
<p>结论：使用 static final 修饰，且显式赋值中不涉及到方法和构造器调用的基本数据类型和 String 的显示赋值是在链接阶段的准备阶段进行</p>
<p>&lt;clinit&gt; 是线程安全的</p>
<h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><p>类的主动使用和被动使用区别在于 &lt;clinit&gt; 方法调用与否，主动使用会调用</p>
<p>类的主动使用</p>
<ol>
<li><p>创建实例（序列化、new、反射）</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>调用类/接口的静态字段（final 另算）</p>
</li>
<li><p>调用 java.lang.reflect 包中反射类的方法，比如 Class.forName()</p>
</li>
<li><p>调用子类的 &lt;clinit&gt; 先触发父类的 &lt;clinit&gt;，但不适用接口</p>
</li>
<li><p>如果一个接口有 default 方法，直接或间接实现该类的初始化会先初始化该接口</p>
</li>
<li><p>JVM 会先初始化主类</p>
</li>
<li><p>MethodHandle </p>
</li>
</ol>
<p>类的被动使用</p>
<ol>
<li><p>通过子类引用调父类的静态字段不会造成子类初始化</p>
</li>
<li><p>通过数组定义类引用不会造成类的初始化</p>
</li>
<li><p>引用常量不会造成类的初始化（常量在链接阶段赋值）</p>
</li>
<li><p>ClassLoader 的 loadClass() 方法不是类的主动使用</p>
</li>
</ol>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>方法区的回收很苛刻，要满足下面三个条件</p>
<ol>
<li><p>类的所有实例被回收</p>
</li>
<li><p>类的加载器被回收（很难达成）</p>
</li>
<li><p>Class 对象的引用被回收</p>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>基本数据类型已预先定义，引用类型才需要类加载器</p>
<p>类的唯一性和命名空间：</p>
<p>比较两个类是否想等只有在同一个加载器下才有意义</p>
<p>命名空间由该类及其所有父加载器所加载的类组成，在同一个命名空间中不会出现类的完整名字相同的俩类，不同命名空间可以</p>
<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>由 c 实现，其他三个加载器都算自定义加载器实现，另外三个都派生与 ClassLoader 抽象类，自定义加载其都应该有自己的「父」加载器，即下层加载器包含上层加载器</p>
<p>引导类加载器用来加载 Java 的核心类库（JAVA_HOME/jre/lib/rt.jar）</p>
<p>引导类加载器不继承 ClassLoader，没有父加载器</p>
<p>出于安全考虑，引导类加载器只加载包名以 java javax sun 开头的类</p>
<p>扩展类加载器和系统类加载器是由引导类加载器加载的</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>用来加载 JAVA_HOME/jre/lib/ext 的类库</p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>是默认的加载器</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>本质为类的加载顺序：引导类 —&gt; 拓展类 —&gt; 系统类/自定义</p>
<p>优点：避免类的重复加载和防止核心 API 篡改</p>
<p>弊端：顶层的加载器无法加载下层加载器加载的类</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 性能监控与调优</title>
    <url>/blog.github.io/2022/04/02/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="监控之命令行工具"><a href="#监控之命令行工具" class="headerlink" title="监控之命令行工具"></a>监控之命令行工具</h2><ol>
<li><p>jps 查看线程</p>
</li>
<li><p>jstat 查看 JVM 统计信息</p>
<ul>
<li><p>-class 类装载信息</p>
</li>
<li><p>-compiler JIT 编译过的方法、耗时等信息</p>
</li>
<li><p>-printcompilation 编译过的方法</p>
</li>
<li><p>-gc GC 相关的堆信息，包括伊甸园区、幸存者区、老年代、方法区</p>
</li>
<li><p>-gcutil 和 -gc 差不多，但是显示的主要是占比</p>
</li>
<li><p>-gccause GC 的原因</p>
</li>
</ul>
</li>
<li><p>jinfo 实时查看和修改 JVM 运行参数信息</p>
</li>
<li><p>jmap 导出堆内存映像文件和内存使用情况/dump（还有其他功能）</p>
</li>
<li><p><del>jhat JDK 自带堆分析工具</del></p>
</li>
<li><p>jstack 栈快照</p>
</li>
<li><p>jcmd 以上除了 jstat 的所有功能</p>
</li>
</ol>
<h2 id="监控之-UI-工具"><a href="#监控之-UI-工具" class="headerlink" title="监控之 UI 工具"></a>监控之 UI 工具</h2><p>jconsole visual mat(dump) jprofiler <a href="https://arthas.aliyun.com/doc/">arthas</a> jmc</p>
<p>浅堆：对象本身占用的内存，不包括其内部引用对象的大小</p>
<p>深堆：一个对象直接或间接访问到的所有对象浅堆大小只和，而且是<code>只能通过</code>该对象访问，即被释放以后释放的真实大小</p>
<p>支配树：所有指向 B 对象的路径都经过对象 A，则认为 A 为 B 的支配者</p>
<h3 id="再谈内存泄露"><a href="#再谈内存泄露" class="headerlink" title="再谈内存泄露"></a>再谈内存泄露</h3><p>严格来说只有不被程序用到但 GC 又无法回收才叫内存泄露，但实际上有些不太好的实现导致对象生命周期过长甚至造成 OOM 也可以叫做宽泛意义上的「内存泄露」。内存泄露过多可造成内存溢出。</p>
<p><code>内存泄露的 8 种情况</code>：</p>
<ol>
<li><p>静态集合类</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>内部类执有外部类</p>
</li>
<li><p>各种连接，数据库、网络 IO 等</p>
</li>
<li><p>不合理的变量作用域，比如只在方法中引用的局部变量的却搞成成员变量</p>
</li>
<li><p>hash 值问题，集合的</p>
</li>
<li><p>缓存泄露</p>
</li>
<li><p>监听器和回调</p>
</li>
</ol>
<p><code>OQL</code></p>
<p>用来查询堆中对象，类似 SQL</p>
<h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><ol>
<li><p>标准参数类型（java -help 列出所有）</p>
</li>
<li><p>-X 非标准类型 （java -X 列出所有）</p>
<p>编译器相关：-Xint(解释器)、-Xcomp(编译器)、-Xmixed(混合模式)</p>
<p>-Xss&lt;大小&gt;(栈大小)、-Xms&lt;大小&gt;(初始堆大小)、-Xmx&lt;大小&gt;(最大堆大小) 属于 -XX 参数的缩写</p>
</li>
<li><p>-XX 非标准类型</p>
<ul>
<li><p>Boolean 类型：-XX:+&lt;option&gt; 表示启用某项 -XX:+&lt;option&gt; 表示禁用某项</p>
</li>
<li><p>非 Boolean 类型：-XX:+&lt;option&gt;=&lt;value&gt;</p>
</li>
<li><p>-XX:+PrintFlagsFinal 输出所有参数的名称和默认值，jinfo 设置运行中的 JVM 参数</p>
</li>
</ul>
</li>
<li><p>堆、栈、方法区相关参数</p>
<p>-Xss&lt;大小&gt;：每个线程栈的大小</p>
<p>-Xms&lt;大小&gt;：初始堆大小</p>
<p>-Xmx&lt;大小&gt;：最大堆大小</p>
<p>-XX:NewSize=&lt;大小&gt;：年轻代大小</p>
<p>-XX:MaxNewSize=&lt;大小&gt;：年轻代最大大小</p>
<p>-XX:NewRatio=&lt;比例&gt;：老年代和新生代比值，默认为 2</p>
<p>-XX:SurvivorRatio=&lt;比例&gt;：伊甸园区和幸存者区比例，默认为 8</p>
<p>-XX:+UseAdaptionSizePolicy: 新生代自动分配，默认打开，优先级高于 SurvivorRatio</p>
<p>-XX:MaxTenuringThreshold=&lt;大小&gt;：新生代每次 MinorGC 之后还存活的对象年龄 +1，大于此年龄收到老年代，默认为 15</p>
<p>-XX:+PrintTenuringDistribution：每次 MinorGC 之后打印幸存者区对象的年龄分布</p>
<p>-XX:MetaspaceSize=&lt;大小&gt;：元空间大小</p>
<p>-XX:MaxMetaspaceSize=&lt;大小&gt;：元空间最大小</p>
</li>
<li><p>OOM 相关参数</p>
<p>-XX:+HeapDumpOnOutOfMemoryError：内存出现 OOM 时，生成 Heap 转储文件以便后续分析</p>
<p>-XX:+HeapDumpBeforeFullGC：FullGC 之前转储</p>
<p>-XX:HeapDumpPath=&lt;路径&gt;：转储文件位置</p>
<p>-XX:OnOutofMemory=&lt;可执行文件&gt;：当 OOM 之后执行</p>
</li>
<li><p>垃圾回收器相关参数</p>
<p>-XX:+UseSerialGC 新生代使用 SerialGC，老年代使用 SerialOldGC，SerialGC 是 Client 模式下默认的回收器</p>
<p>-XX:+UseParNewGC 新生代使用 ParNewGC，老年代不受影响</p>
<p>-XX:+UseParallelGC 新生代使用 ParallelGC，老年代使用 ParallelOldGC，JDK8 默认</p>
<p>-XX:ParallelGCThreads=&lt;个数&gt; 设置年轻代并行回收器的线程数</p>
<p>-XX:MaxGCPauseMillis=&lt;秒数&gt; 设置 GC 最大 STW 时间</p>
<p>-XX:GCTimeRatio=&lt;比例&gt; 垃圾回收时间与总时间的占比，用来衡量吞吐量，默认 99，范围 （0，100）</p>
</li>
<li><p>GC 日志相关</p>
<p>-XX:+PrintGC/-XX:+PrintGCDetails 打印日志</p>
<p>-XX:+PrintGCTimeStamp/-XX:+PrintGCDateStamp 打印日志时间戳和前面的配合使用</p>
<p>-XX:+PrintHeapAtGC 每次 GC 前后 打印堆信息</p>
<p>-X:Loggc:&lt;文件&gt; 输出到文件</p>
</li>
<li><p>其他参数</p>
<p>-XX:+DoEscapeAnalySis 开启逃逸分析</p>
<p>-XX:+UseBiasedLock 开启偏向锁</p>
<p>-XX:+UseTLAB 开启 TLAB，默认打开</p>
<p>-XX:+PrintTLAB 打印 TLAB 的使用情况</p>
<p>-XX:TLABSize 设置 TLAB 大小</p>
</li>
</ol>
<h2 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h2><p><a href="https://gceasy.io">GCEasy</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>archLinux 安装</title>
    <url>/blog.github.io/2021/12/28/archLinux-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文采用efi分区，因为厌烦了grub故换systemd-boot，桌面为bspwm，硬件为Intel cpu和amd gpu</p>
<h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><h3 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h3><p>ls /sys/firmware/efi/efivars</p>
<span id="more"></span>

<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>iwctl </p>
<h3 id="检查是否联通"><a href="#检查是否联通" class="headerlink" title="检查是否联通"></a>检查是否联通</h3><p>ping -c 3 archlinux.org</p>
<h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><p>timedatectl set-ntp true </p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><pre><code>1. fidsk /dev/sda
2. g新建gpt分区表
3. n新建分区 ,类型序号开头都回车结尾定义空间大小，然后t改成efi
4. p查看完成的分区表，w保存退出
5. 自改分区如下
    1. sda1 +512M EFI
    2. sda2 +50G 
    3. sda3 余下
</code></pre>
<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><pre><code>1.  mkfs.fat -F32 /dev/sda1
2.  mkfs.ext4 /dev/sda2
3.  mkfs.ext4 /dev/sda3
</code></pre>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><pre><code>1.  mount /dev/sda2  /mnt
2.  mkdir -p /mnt/boot &amp; mount /dev/sda1  /mnt/boot
3.  mkdir -p /mnt/home &amp; mount /dev/sda3  /mnt/home
</code></pre>
<h3 id="安装基本操作系统"><a href="#安装基本操作系统" class="headerlink" title="安装基本操作系统"></a>安装基本操作系统</h3><p>pacstrap /mnt base linux linux-firmware vim iwd </p>
<h3 id="配置挂载信息"><a href="#配置挂载信息" class="headerlink" title="配置挂载信息"></a>配置挂载信息</h3><p>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</p>
<h3 id="切换到安装到系统"><a href="#切换到安装到系统" class="headerlink" title="切换到安装到系统"></a>切换到安装到系统</h3><p>arch-chroot /mnt </p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>1. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
2. hwclock --systohc
</code></pre>
<h3 id="本地化编码"><a href="#本地化编码" class="headerlink" title="本地化编码"></a>本地化编码</h3><pre><code>1.  vim /etc/locale.gen，反注释zh_CN.UTF-8 UTF-8和us_EN.UTF-8
2.  locale-gen
3.  vim /etc/locale.conf 加入 LANG=en_US.UTF-8
</code></pre>
<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><pre><code>1. echo “shaka-arch” &gt;&gt; /etc/hostname
2. /etc/hosts 
    127.0.0.1   localhost
    ::1             localhost
    127.0.1.1   shaka-arch.localdomain  shaka-arch
</code></pre>
<h3 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h3><pre><code>1. passwd
2. useradd -m xxx 然后passwd xxx
</code></pre>
<h3 id="Intel微码"><a href="#Intel微码" class="headerlink" title="Intel微码"></a>Intel微码</h3><p>pacman -S intel-ucode</p>
<h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><pre><code>1.  bootctl --path=/boot$esp install
2.  vim /boot/loader/loader.conf （没有下面的序号）
    1. default arch #默认引导的系统，注意这里的 arch 对应的是 arch.conf
    2. timeout 1    #在引导界面停留的时间，如果你想引导不止一个系统，不应将这一项设置成0
    3. editor    0    #这将会禁用编辑内和参数的功能，默认是开启的，如果你的计算机可能被他人使用，将该功能关闭是推荐的选择
3. vim /boot/loader/entries/arch.conf
    1. title Arch Linux               #这是启动选项的名称，将会出现在引导界面
    2. linux   /vmlinuz-linux         #压缩的可引导内核，用于系统启动
    3. initrd  /intel-ucode.img       #由芯片制造商提供的对 CPU 微码的稳定性和安全性更新，按照 Arch wiki 的说法它应当是&#39; first initrd in the bootloader config file&#39;
    4. initrd  /initramfs-linux.img   #为内核提供的一个临时的文件系统
    5. options root=/dev/sdap2 rw     #/root 挂载的位置，可以由 LABEL, PARTUUID 或者 UUID识别，此处使用了块设备的路径
</code></pre>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>1.  systemctl enable systemd-networkd
2.  systemctl enable systemd-resolved
3.  systemctl enable systemd-timesyncd
4.  systemctl enable iwd
</code></pre>
<h3 id="加入sudoers"><a href="#加入sudoers" class="headerlink" title="加入sudoers"></a>加入sudoers</h3><p>pacman -S sudo 然后 EDITOR=vim visudo </p>
<h3 id="复制网络配置到新系统"><a href="#复制网络配置到新系统" class="headerlink" title="复制网络配置到新系统"></a>复制网络配置到新系统</h3><p>cp /etc/systemd/network/* /mnt/etc/systemd/network/ </p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>exit 然后 umount -R /mnt 接着reboot重启机器</p>
<h2 id="桌面bspwm"><a href="#桌面bspwm" class="headerlink" title="桌面bspwm"></a>桌面bspwm</h2><pre><code>1. sudo pacman -S xf86-video-amdgpu alsa alsa-utils显卡声卡驱动
2. alsamixer 调节音量
3. sudo pacman -S xorg 图形服务
4. sudo pacman -S bspwm sxhkd feh 
5. yay -S polybar 状态栏
6. 安装完成后需要在$HOME/.xinitrc中添加exec bspwm，然后通过startx即可启动。
7. 在家目录下分别新建文件夹 .config/bspwm   .config/sxhkd   .config/polybar用于存放对应配置，分别是bspwm，快捷键和polybar的基本配置文件，初始配置可从/usr/share/doc中获取
8. alacritty 终端模拟器 ranger 文件管理器 sxiv 图片浏览 rofi程序查找
9. 壁纸feh --bg-fill --randomize --recursive IMAGES_DIR_PATH 加入到bspwmrc配置文件
10. wqy-microhei中文字体
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>archLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 设计模式</title>
    <url>/blog.github.io/2022/04/03/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p><code>一般关联关系</code></p>
<p>单向关联：用带箭头的指向被关联类的实线表示</p>
<p>双向关联：用实线表示</p>
<p>自关联：带箭头的指向自己的实线表示</p>
<p><code>聚合关系</code></p>
<p>聚合关系是强关联关系，成员对象是整体对象的一部分，但成员对象也可以单独存在，用带空心菱形的实线表示</p>
<p><code>组合关系</code></p>
<p>组合是更强烈的聚合，成员不可以单独存在，用带实心菱形的实线表示</p>
<p><code>依赖关系</code></p>
<p>耦合度最弱的一种关联方式，是临时性的关联，在代码中通过局部变量、方法参数或静态方法调用来调用被依赖类的某些方法完成某些职责，用带箭头的虚线表示，指向被依赖类</p>
<p><code>继承关系</code></p>
<p>带实心三角的实线表示，子类指向父类</p>
<p><code>实现关系</code></p>
<p>带空心三角的虚线表示，实现类指向接口</p>
<h3 id="软件设计六原则："><a href="#软件设计六原则：" class="headerlink" title="软件设计六原则："></a>软件设计六原则：</h3><blockquote>
<p>为了提高软件系统的可维护性、可复用性 增加可扩展性和灵活性</p>
</blockquote>
<ol>
<li><p>开闭原则</p>
<p> 对扩展开放，对修改关闭，在需要扩展的时候不去修改源代码，实现热插拔，要达到这样的效果需要使用接口和抽象类</p>
</li>
<li><p>里氏替换原则</p>
<p> 父类可以出现的地方子类也可以出现，通俗来说就是子类可以扩展父类功能但尽量不要重写父类的方法  </p>
</li>
</ol>
<ol start="3">
<li><p>依赖倒转原则</p>
<p> 高层模块不应该依赖低层模块，两者应该依赖其抽象，简单说就面对抽象进行编程。</p>
</li>
<li><p>接口隔离原则</p>
<p> 客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小接口之上。</p>
</li>
<li><p>迪米特法则</p>
<p> 只和认识的人说话，不和陌生人说话。当两个软件无须直接通信，那么不应该发生直接调用，而是通过第三方调用，目的是为了降低耦合度。</p>
</li>
<li><p>合成复用原则</p>
<p> 尽量先使用聚合和组合实现关联关系，其次才考虑用继承实现。</p>
<p> 继承复用虽然简单，但父类对子类来说是透明的，属于「白箱」复用，父类的任何改变都会造成子类的改变，耦合度高，并且从父类继承而来的实现是静态的，限制了复用的灵活性。</p>
<p> 组合/聚合复用将已有对象纳入新对象中，新对象可以调用已有对象的功能。新对象对已有对象细节不知，维护了封装性，属于「黑箱」复用，可以声明抽象降低耦合，并且新对象可以引用和已有对象成分相同的对象，灵活性高</p>
</li>
</ol>
<h3 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h3><blockquote>
<p>对象的创建与使用分离使用者不关心对象的创建细节</p>
</blockquote>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>角色：单例类（只能创建一个实例的类）和访问类（使用单例类的类）</p>
<p>饿汉式（静态变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式（静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果方法加上 synchronized 是安全但是效率太差，因为对于读操作是线程安全的而大部分操作又是读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（双重检查）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 防止指令重排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查过滤掉读操作</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查为了保证单例</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（静态内部类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>第一次加载 Singleton 类时并不会初始化 SINGLETON，只有第一次调 getInstance() 时 JVM 才会加载 SingletonHolder 并初始化 SINGLETON。这样不仅能保证线程安全也可以保证实例的唯一性，并且没有空间浪费（饿汉式会浪费）。是开源项目比较常用的一种单例模式方式。</p>
<p>饿汉式（枚举类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE(<span class="string">&quot;shaka&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SingletonEnum(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>写法简单且是唯一一种不会被破坏的单例模式，极力推荐，破坏单例模式的方式可以序列化反序列化也可以反射创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解决反射破坏单例的解决方案</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不能创建多个对象&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决序列化破坏单例，会自动调用 readObject()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange >说明：</font></p>
<p>解决序列化和反射破坏单例模式的方式</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>角色：抽象产品、具体产品、具体工厂</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存与垃圾回收</title>
    <url>/blog.github.io/2022/03/23/jvm/</url>
    <content><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>此处只是基本介绍，关于加载篇 <a href="/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/#类的加载">请看</a></p>
</blockquote>
<p>类的加载分为三个阶段，即加载、链接和初始化</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>引导类加载器</p>
<p> c/c++ 语言编写，无法获取，用于加载java的核心类库</p>
</li>
<li><p>扩展类加载器</p>
<p> 加载 java.ext.dirs 系统路径所指定的类库，自己的应用放在其中也可以由扩展类加载器加载</p>
</li>
<li><p>系统类加载器</p>
<p> 加载自己的 java 应用程序</p>
</li>
<li><p>自定义类加载器</p>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>java虚拟机对 class 文件的加载是按需加载，收到加载请求先由父加载器加载，加载失败则由子加载器加载</p>
<p>判断 Class 是否为同一个，则需要全限定类名和类加载器都相同</p>
<p>优势</p>
<ol>
<li><p>防止重复加载</p>
</li>
<li><p>防止核心 API 被篡改</p>
</li>
</ol>
<h2 id="内存与垃圾回收篇"><a href="#内存与垃圾回收篇" class="headerlink" title="内存与垃圾回收篇"></a>内存与垃圾回收篇</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>图示</p>
<p><img src="/blog.github.io/2022/03/23/jvm/1.png"></p>
<p>上图红色的共享，灰色的每个线程独有</p>
<h3 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h3><p>用来存储 java 指令的地址，运行速度快且不会内存溢出</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>运行速度仅次于 PC 寄存器，基本单位为栈帧，设置栈大小 Xss</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>内部结构：<code>局部变量表</code>、<code>操作数栈</code>、动态链接、方法返回地址、一些附加信息</p>
<ol>
<li><p>局部变量表</p>
<p> 基本单位为 slot，存放基本数据类型和引用，long 和 double 占两个 slot，非静态方法的第一个变量为 this，其他按声明顺序排序，且一旦销毁可以重用</p>
<p> 类变量在链接的 prepare 阶段默认赋值，在初始化阶段显式赋值和静态代码块赋值</p>
<p> 实例变量随着对象的创建在堆空间赋值</p>
<p> 局部变量必须显式赋值</p>
</li>
<li><p>操作数栈</p>
<p> 根据字节码指令往操作数栈中存取数据，主要用来保存计算过程中的中间结果，同时作为计算过程变量的临时保存空间，刚有栈帧时操作数栈是空的，但最大深度在编译器就定义好了</p>
</li>
</ol>
<ol start="3">
<li><p>动态链接</p>
<p> 指向运行时常量池的方法的引用</p>
</li>
<li><p>方法的调用</p>
<p> 早起绑定（编译期确定）和晚期绑定（运行期确定/多态）</p>
<p> 非虚方法：静态方法、私有方法、final 方法、实例构造器、父类方法</p>
<p> 虚方法：其他方法</p>
<p> 在类加载的链接阶段为了提高性能会创建一个虚方法表，已经重写的用自己的，没重写的记录下来不必一层层向上找</p>
</li>
<li><p>方法返回地址</p>
<p> 存放调用该方法的 PC 寄存器的值</p>
</li>
<li><p>栈帧附加信息</p>
</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>有时 java 应用需要与外部环境交互，这是本地方法存在的主要原因，本地方法栈并非所有虚拟机都有</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一个进程一个 jvm 实例，一个 jvm 实例一个运行时数据区，一个堆区，一个进程多个线程，一个线程一个栈、一个 pc 寄存器、一个本地方法栈，堆(除了TLAB)和方法区多个线程共享，堆是 GC 的重点</p>
<h3 id="堆的细分"><a href="#堆的细分" class="headerlink" title="堆的细分"></a>堆的细分</h3><p>jdk7 及以前分为新生代、老年代和永久代（逻辑上）</p>
<p>jdk8 以后分为新生代、老年代和元空间（逻辑上）</p>
<p>新生代分为伊甸园区和幸存者区</p>
<p>Xms 设置初始（新生代 + 老年代）大小， Xmx 设置最大（新生代 + 老年代）值，-XX:NewRatio 配置新生代与老年代占比，-XX: SurvivorRatio 配置伊甸园区与幸存者区占比</p>
<p>对象不一定创建在堆中，可以开启逃逸分析开启栈上分配</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><ul>
<li><p>新对象优先放伊甸园区</p>
</li>
<li><p>当伊甸园区空间满了又需要放入新对象，则进行 young GC/Minor GC，将不再需要的垃圾回收，再把新对象放入伊甸园区，将剩余的放入幸存者区</p>
</li>
<li><p>当伊甸园区再次满了，则再次垃圾回收将没回收的对象放入另一块幸存者区，同时将原来的幸存者区的对象也放入这块幸存者区</p>
</li>
<li><p>当幸存者区对象的年龄达到阈值值提升进老年代，默认15</p>
</li>
<li><p>当伊甸园区满了才会 young GC/Minor GC，幸存者区满了不会触发 young GC/Minor GC，但幸存者区的无用对象在 young GC/Minor GC  的时候也会被回收</p>
</li>
<li><p>大部分对象朝生夕死，在 young GC/Minor GC 就被回收掉了</p>
</li>
<li><p>如果新对象新生代 young GC 后还放不下则直接准备放进老年代，如果老年代放不下进行 Major GC，Major GC 之后放得下放进老年代，放不下则 OOM</p>
</li>
<li><p>当 young GC 时幸存者区放不下伊甸园区来的对象则放进老年代</p>
</li>
<li><p>young GC 会清空伊甸园区</p>
</li>
<li><p>TLAB 是在伊甸园区为每个线程创建的一小块区域，为线程私有，空间很小，无线程安全问题，对象优先分配在 TLAB 空间</p>
</li>
<li><p>栈上分配 &gt; TLAB 上分配 &gt; eden 区 &gt; 老年代创建对象，其中栈上分配和 TLAB 分配考虑到逃逸分析所以无线程安全问题</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于储存已经加载的类信息、运行时常量池、静态变量、JIT 代码缓存等</p>
<p>Hotspot 方法区的变化：</p>
<p><img src="/blog.github.io/2022/03/23/jvm/2.png"></p>
<hr>
<p>为什么去永久代？</p>
<ol>
<li><p>永久代大小很难确定，小了容易 Full GC 造成 STW，大了造成浪费</p>
</li>
<li><p>永久代调优困难</p>
</li>
</ol>
<hr>
<p>为什么 StringTable 换位置？</p>
<p>放在堆里回收效率更高</p>
<hr>
<p>方法区的垃圾回收主要针对类的卸载和常量池，不同虚拟机不一定都有方法区的回收</p>
<h3 id="对象的实例化、内存布局及访问定位"><a href="#对象的实例化、内存布局及访问定位" class="headerlink" title="对象的实例化、内存布局及访问定位"></a>对象的实例化、内存布局及访问定位</h3><p>对象实例化的几种方式：new、反射、反序列化、clone、第三方库</p>
<p>对象的创建步骤：</p>
<ol>
<li><p>对象对应的类是否加载、链接、初始化</p>
</li>
<li><p>为对象分配内存</p>
</li>
<li><p>处理并发安全问题</p>
</li>
<li><p>初始化分配到的空间/默认初始化</p>
</li>
<li><p>设置对象头</p>
</li>
<li><p>执行 Init 方法的初始化</p>
</li>
</ol>
<p>对象的内存布局：</p>
<ol>
<li><p>对象头</p>
<ul>
<li><p>运行时元数据</p>
<ul>
<li><p>哈希值</p>
</li>
<li><p>GC 分代年龄</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程ID</p>
</li>
<li><p>偏向线程时间戳</p>
</li>
</ul>
</li>
<li><p>类型指针</p>
</li>
<li><p>如果是数组，还得记录数组长度</p>
</li>
</ul>
</li>
<li><p>实例数据</p>
</li>
<li><p>对齐填充</p>
</li>
</ol>
<p>对象的访问主要有句柄访问和直接访问</p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>解释器：响应速度快</p>
<p>JIT编译器：效率高</p>
<p>jvm 启动时解释器首先发挥作用，无需等待编译器全部编译完成再执行，省却不必要的编译时间，随着时间推移，编译器发挥作用，越来越多的代码被编译成本地代码，获得更高的执行效率</p>
<p>一个被多次调用的方法，或者一个方法体内部循环次数较多的循环体被称作「热点代码」，可以通过 JIT 编译为本地代码，由于编译发生在方法执行过程中，因此被称为栈上替换(OSR)</p>
<p>HotSpot 采用方法调用计数器和回边计数器判定热点代码</p>
<p>方法调用计数器 Server 模式(64 位系统默认)下阈值为 10000，Client 模式下为 1500，如果超过一定时间仍不足以达到阈值，则会进入半衰期，半衰回收发生在 GC 时</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JDK1.8 以前用 char 数组，9 以后用 byte 数组，因为大部分情况下都是拉丁字符，为了省空间改为 byte，为了兼容中文等字符，加上编码标记</p>
<p>String 不可变</p>
<p>字符串常量池不会存储相同的字符串，是一个固定大小的 HashTable</p>
<p>拼接操作：</p>
<pre><code>字符串常量与字符串常量拼接结果在字符串常量池，原因是编译期优化

出现变量相当于堆中 new String()

intern() 判断常量池中是否存在，存在返回地址，否则加载一份并返回地址
</code></pre>
<h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><p>垃圾回收针对<code>堆</code>和方法区，程序计数器没有 GC 没有溢出，栈和本地方法栈没有 GC 有 StackOverFlow</p>
<h4 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h4><p><code>引用计数算法</code></p>
<p>使用引用计数器</p>
<p>优点：简单便于标识，效率比较高，回收没有延迟</p>
<p>缺点: 增加储存空间和计数开销，最糟糕的是无法处理循环引用，因此 Java 不用该算法</p>
<p><code>可达性分析算法</code></p>
<p>直接或间接连接 GC Roots</p>
<p>GC Roots:</p>
<ul>
<li><p>栈引用的对象</p>
</li>
<li><p>本地方法引用的对象</p>
</li>
<li><p>静态属性、常量引用的对象</p>
</li>
<li><p>被同步锁持有的对象</p>
</li>
<li><p>Java 虚拟机内部引用</p>
</li>
</ul>
<h4 id="清除算法"><a href="#清除算法" class="headerlink" title="清除算法"></a>清除算法</h4><p><code>标记清除算法</code></p>
<p>从根对象标记所有可达对象，然后线性遍历堆中所有对象删除不可达对象</p>
<p>缺点：效率低、碎片化</p>
<p><code>复制算法</code></p>
<p>使用两块空间，每次只使用一块，然后把可达对象复制到另一块空间，需要复制的对象越少越好，例如新生代朝生夕死</p>
<p>优点：高效、无碎片化</p>
<p>缺点：需要两倍空间、需要维护引用关系</p>
<p><code>标记压缩算法</code></p>
<p>标记所有被引用对象，然后移动到内存的一端清除其他</p>
<p>优点：消除了标记清除算法的碎片化和复制算法的 2 倍空间浪费</p>
<p>缺点：效率不如复制算法，移动时需要调整引用位置</p>
<p><code>分代收集算法</code></p>
<p>新生代对象生命周期短，存活率低、回收频繁，用复制算法，空间浪费用两块幸存者区补偿，老年代空间大、对象大、存活率高、生命周期长回收频率又低适合标记清除和标记压缩的混合实现</p>
<h3 id="垃圾回收相关"><a href="#垃圾回收相关" class="headerlink" title="垃圾回收相关"></a>垃圾回收相关</h3><p>System.gc() 不一定马上调用垃圾回收</p>
<p>严格来说只有对象不被用到又无法 GC 才算内存泄露，内存泄露有可能导致内存溢出</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>强引用</code></p>
<p>传统的引用，只要引用关系在就不会被回收，强引用是造成内存泄露的主要原因之一</p>
<p><code>软引用</code></p>
<p>在内存溢出之前列入回收范围之内进行第二次回收，如果回收完还是不够则内存溢出，即内存不够则回收，典型应用场景比如高速缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftReference = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="string">&quot;shaka&quot;</span>, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<p><code>弱引用</code></p>
<p>只能生存到下一次垃圾回收之前，当 GC 工作时无论是否引用都会被回收，即发现即回收</p>
<p><code>虚引用</code></p>
<p>对其生存没影响也不能通过引用获得对象，唯一目的是回收时收到一个系统通知</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="/blog.github.io/2022/03/23/jvm/3.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3</title>
    <url>/blog.github.io/2022/02/21/vue3/</url>
    <content><![CDATA[<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p><a href="https://cn.vitejs.dev/">新一代构建工具</a></p>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>组合式api,数据、方法等都要配置在setup函数中，并且必须返回，响应式基本数据类型、对象类型用ref，对象类型用reactive</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = ref(<span class="string">&#x27;shaka&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tom = reactive(&#123;<span class="attr">uname</span>:<span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name.value);</span><br><span class="line">    tom.age = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(tom)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    say,</span><br><span class="line">    tom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>setup仅在beforeCreated执行一次，且this为undefined</p>
<p>props父组件向子组件传参,context上下文对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.p1);</span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> lastName = <span class="string">&#x27;jerry&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      firstName,</span><br><span class="line">      lastName,</span><br><span class="line">      fullName,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监视</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = ref(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      a.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    watch(a,<span class="function">(<span class="params">newValue,oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a的值变了&#x27;</span>,newValue,oldValue)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      add,</span><br><span class="line">      a</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
</search>
