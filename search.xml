<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM 字节码与类的加载</title>
    <url>/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p><code>魔数</code></p>
<p>标识合法的 class 文件，4 个字节</p>
<p><code>版本号</code></p>
<p>4 个字节，主版本和副版本，从 45 开始，每个版本加 1，高版本的虚拟机可以执行低版本编译生成的 class 文件，反之不行</p>
<p><code>常量池</code></p>
<p>构成：常量池计数器( 1 个字节 )和常量池表( N 个字节 )</p>
<p>常量池表构成：字面量和符号引用</p>
<p><code>访问标识</code></p>
<p><code>类索引</code></p>
<p><code>父类索引</code></p>
<p><code>接口索引集合</code></p>
<p><code>字段表集合</code></p>
<p>构成：字段计数器、字段表</p>
<p><code>方法表集合</code></p>
<p>构成：方法计数器、方法表</p>
<p><code>属性集合</code></p>
<p>构成：属性计数器、属性表</p>
<h3 id="javac-与-javap"><a href="#javac-与-javap" class="headerlink" title="javac 与 javap"></a>javac 与 javap</h3><p>javac -g 与没有 -g 参数相比多了局部变量表等信息，idea 和 eclipse 默认有 -g 参数</p>
<p>javap -v 反汇编，详细，加上 -p 显示私有</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>指令由操作码和操作数(很多没有)构成</p>
<p>局部变量表、操作数栈以槽位为单位，byte short int boolean floot char 占4个字节，一个槽位，其中byte short char 存储时自动转为 int 以占满 4 个字节，double long 占 8 个字节，2 个槽位，引用类型也占一个槽位</p>
<p><code>压栈指令</code></p>
<p>从局部变量表压入操作数栈，load </p>
<p><code>常量入栈指令</code></p>
<p>const: int long double float 和引用类型使用</p>
<p>push: byte short 使用</p>
<p>dc: 万能型</p>
<p><code>出栈装入局部变量表指令</code></p>
<p>store</p>
<p><code>算术指令</code></p>
<p><img src="/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/1.png"></p>
<p><code>类型转换指令</code></p>
<p>宽化类型转换/自动类型转换【简化: int ——&gt; long ——&gt; float ——&gt; double 会发生精度损失】</p>
<ul>
<li><p>int 到 其他: i2l i2f i2d</p>
</li>
<li><p>long 到其他: l2f l2d</p>
</li>
<li><p>float 到其他: f2d</p>
</li>
<li><p>byte short 转换为较大范围类型看作是 int</p>
</li>
</ul>
<p>窄化类型转换【精度损失更大】</p>
<ul>
<li><p>int 到其他: i2s i2b i2c</p>
</li>
<li><p>long 到 int: l2i</p>
</li>
<li><p>float 到其他: f2i f2l</p>
</li>
<li><p>double 到其他: d2f d2l d2i</p>
</li>
</ul>
<p><code>对象和数组的创建指令</code></p>
<p>对象创建指令：new</p>
<p>数组的创建指令：newarray（基本数据类型）anewarray（引用数据类型）multianewarray（多维数组）</p>
<p><code>字段访问指令</code></p>
<p>类字段：getstatic putstatic</p>
<p>实例字段：gefield putfield</p>
<p><code>数组操作指令</code></p>
<p>aload（压栈） astore（赋值） arraylength（数组长度）</p>
<p><code>类型检查指令</code></p>
<p>instanceof checkcast</p>
<p><code>方法调用指令</code></p>
<p>invokevirtual：虚方法分派，支持多态</p>
<p>invokeinterface：调用接口方法</p>
<p>invokespecial：构造器、私有和父类方法</p>
<p>invokestatic：类方法</p>
<p><code>方法返回指令</code></p>
<p>return</p>
<p><code>操作数栈管理指令</code></p>
<p>弹出：pop 复制：dup 交换数值：swap</p>
<p><code>比较指令</code></p>
<p>dcmpg dcmpl fcmpg fcmpl lcmp</p>
<p>double float 有两套是因为 Nan 值处理方式不同，例如 fcmpg 压入 1，fcmpl 压入 -1</p>
<p><code>条件跳转指令</code></p>
<p>ifeq iflt ifle ifne ifgt ifge （用来比较 long float 和 double）</p>
<p><code>比较条件跳转指令</code></p>
<p>if_icmpeq if_icmpne if_icmplt if_icmpgt if_icmpge if_icmpeq if_acmpeq if_acmpne</p>
<p><code>多条件跳转指令</code></p>
<p>tablestitch（连续的值） lookupstitch（不连续但会进行排序）</p>
<p><code>无条件跳转指令</code></p>
<p>goto</p>
<p><code>抛出异常指令</code></p>
<p>athrow 手动抛出</p>
<p><code>异常处理指令</code></p>
<p>处理异常是由异常表实现的，并没有 try catch 体现</p>
<p><code>同步指令</code></p>
<p>方法级的同步和普通方法指令没区别，当通过访问标志判断某方法是同步方法会自动在方法调用前加锁</p>
<p>同步代码块：monitorenter monitorexit，通过异常表维护释的放锁，如果监视器计数器为 0 则进入，为 1 则判断监视器线程是否为自己，为自己进入，否则等待</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><code>过程一：加载阶段</code></p>
<ul>
<li><p>获取二进制流的方式</p>
<ul>
<li><p>通过文件系统读入</p>
</li>
<li><p>通过 jar 等数据包提取文件</p>
</li>
<li><p>通过网络加载</p>
</li>
<li><p>在运行时动态生成</p>
</li>
</ul>
</li>
<li><p>类模版和 Class 的位置</p>
<p>  类模版在方法区，Class 实例在堆区</p>
</li>
<li><p>数组类的加载</p>
<p>  数组类并非由类加载器负责创建，而是由 JVM 在运行时根据需要直接创建的</p>
</li>
</ul>
<p><code>过程二：链接阶段</code></p>
<ol>
<li><p>验证</p>
<ul>
<li><p>格式检查（检查魔数、版本和长度，和加载同时进行）</p>
</li>
<li><p>语义检查</p>
</li>
<li><p>字节码验证</p>
</li>
<li><p>符号引用验证</p>
</li>
</ul>
</li>
<li><p>准备</p>
</li>
</ol>
<p>为类中的静态变量分配内存并赋默认值，但并不包括常量，常量在编译时就已经分配，若以字符串字面量方式为常量赋值则也在此阶段显式赋值，在这个阶段并不会有代码的执行</p>
<ol start="3">
<li>解析</li>
</ol>
<p>将类、接口、字段、方法等符号引用转为直接引用，以方法为例，通过解析符号引用可以转为目标方法在方法表中的位置</p>
<p><code>过程三：初始化阶段</code></p>
<p>为静态变量赋予正确的值，到了此阶段才会真正执行代码（静态代码块），&lt;clinit&gt; 方法就是由静态变量的显示赋值和静态代码块构成，此方法由 JVM 自动调用，并且总是先调用父类的 &lt;clinit&gt;</p>
<p>没有静态变量的显式赋值和静态代码块就没有 &lt;clinit&gt;，</p>
<p>结论：使用 static final 修饰，且显式赋值中不涉及到方法和构造器调用的基本数据类型和 String 的显示赋值是在链接阶段的准备阶段进行</p>
<p>&lt;clinit&gt; 是线程安全的</p>
<h3 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h3><p>类的主动使用和被动使用区别在于 &lt;clinit&gt; 方法调用与否，主动使用会调用</p>
<p>类的主动使用</p>
<ol>
<li><p>创建实例（序列化、new、反射）</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>调用类/接口的静态字段（final 另算）</p>
</li>
<li><p>调用 java.lang.reflect 包中反射类的方法，比如 Class.forName()</p>
</li>
<li><p>调用子类的 &lt;clinit&gt; 先触发父类的 &lt;clinit&gt;，但不适用接口</p>
</li>
<li><p>如果一个接口有 default 方法，直接或间接实现该类的初始化会先初始化该接口</p>
</li>
<li><p>JVM 会先初始化主类</p>
</li>
<li><p>MethodHandle </p>
</li>
</ol>
<p>类的被动使用</p>
<ol>
<li><p>通过子类引用调父类的静态字段不会造成子类初始化</p>
</li>
<li><p>通过数组定义类引用不会造成类的初始化</p>
</li>
<li><p>引用常量不会造成类的初始化（常量在链接阶段赋值）</p>
</li>
<li><p>ClassLoader 的 loadClass() 方法不是类的主动使用</p>
</li>
</ol>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>方法区的回收很苛刻，要满足下面三个条件</p>
<ol>
<li><p>类的所有实例被回收</p>
</li>
<li><p>类的加载器被回收（很难达成）</p>
</li>
<li><p>Class 对象的引用被回收</p>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>基本数据类型已预先定义，引用类型才需要类加载器</p>
<p>类的唯一性和命名空间：</p>
<p>比较两个类是否想等只有在同一个加载器下才有意义</p>
<p>命名空间由该类及其所有父加载器所加载的类组成，在同一个命名空间中不会出现类的完整名字相同的俩类，不同命名空间可以</p>
<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><p>由 c 实现，其他三个加载器都算自定义加载器实现，另外三个都派生与 ClassLoader 抽象类，自定义加载其都应该有自己的「父」加载器，即下层加载器包含上层加载器</p>
<p>引导类加载器用来加载 Java 的核心类库（JAVA_HOME/jre/lib/rt.jar）</p>
<p>引导类加载器不继承 ClassLoader，没有父加载器</p>
<p>出于安全考虑，引导类加载器只加载包名以 java javax sun 开头的类</p>
<p>扩展类加载器和系统类加载器是由引导类加载器加载的</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>用来加载 JAVA_HOME/jre/lib/ext 的类库</p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>是默认的加载器</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>本质为类的加载顺序：引导类 —&gt; 拓展类 —&gt; 系统类/自定义</p>
<p>优点：避免类的重复加载和防止核心 API 篡改</p>
<p>弊端：顶层的加载器无法加载下层加载器加载的类</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 性能监控与调优</title>
    <url>/blog.github.io/2022/04/02/JVM-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="监控之命令行工具"><a href="#监控之命令行工具" class="headerlink" title="监控之命令行工具"></a>监控之命令行工具</h2><ol>
<li><p>jps 查看线程</p>
</li>
<li><p>jstat 查看 JVM 统计信息</p>
<ul>
<li><p>-class 类装载信息</p>
</li>
<li><p>-compiler JIT 编译过的方法、耗时等信息</p>
</li>
<li><p>-printcompilation 编译过的方法</p>
</li>
<li><p>-gc GC 相关的堆信息，包括伊甸园区、幸存者区、老年代、方法区</p>
</li>
<li><p>-gcutil 和 -gc 差不多，但是显示的主要是占比</p>
</li>
<li><p>-gccause GC 的原因</p>
</li>
</ul>
</li>
<li><p>jinfo 实时查看和修改 JVM 运行参数信息</p>
</li>
<li><p>jmap 导出堆内存映像文件和内存使用情况/dump（还有其他功能）</p>
</li>
<li><p><del>jhat JDK 自带堆分析工具</del></p>
</li>
<li><p>jstack 栈快照</p>
</li>
<li><p>jcmd 以上除了 jstat 的所有功能</p>
</li>
</ol>
<h2 id="监控之-UI-工具"><a href="#监控之-UI-工具" class="headerlink" title="监控之 UI 工具"></a>监控之 UI 工具</h2><p>jconsole visual mat(dump) jprofiler <a href="https://arthas.aliyun.com/doc/">arthas</a> jmc</p>
<p>浅堆：对象本身占用的内存，不包括其内部引用对象的大小</p>
<p>深堆：一个对象直接或间接访问到的所有对象浅堆大小只和，而且是<code>只能通过</code>该对象访问，即被释放以后释放的真实大小</p>
<p>支配树：所有指向 B 对象的路径都经过对象 A，则认为 A 为 B 的支配者</p>
<h3 id="再谈内存泄露"><a href="#再谈内存泄露" class="headerlink" title="再谈内存泄露"></a>再谈内存泄露</h3><p>严格来说只有不被程序用到但 GC 又无法回收才叫内存泄露，但实际上有些不太好的实现导致对象生命周期过长甚至造成 OOM 也可以叫做宽泛意义上的「内存泄露」。内存泄露过多可造成内存溢出。</p>
<p><code>内存泄露的 8 种情况</code>：</p>
<ol>
<li><p>静态集合类</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>内部类执有外部类</p>
</li>
<li><p>各种连接，数据库、网络 IO 等</p>
</li>
<li><p>不合理的变量作用域，比如只在方法中引用的局部变量的却搞成成员变量</p>
</li>
<li><p>hash 值问题，集合的</p>
</li>
<li><p>缓存泄露</p>
</li>
<li><p>监听器和回调</p>
</li>
</ol>
<p><code>OQL</code></p>
<p>用来查询堆中对象，类似 SQL</p>
<h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><ol>
<li><p>标准参数类型（java -help 列出所有）</p>
</li>
<li><p>-X 非标准类型 （java -X 列出所有）</p>
<p>编译器相关：-Xint(解释器)、-Xcomp(编译器)、-Xmixed(混合模式)</p>
<p>-Xss&lt;大小&gt;(栈大小)、-Xms&lt;大小&gt;(初始堆大小)、-Xmx&lt;大小&gt;(最大堆大小) 属于 -XX 参数的缩写</p>
</li>
<li><p>-XX 非标准类型</p>
<ul>
<li><p>Boolean 类型：-XX:+&lt;option&gt; 表示启用某项 -XX:+&lt;option&gt; 表示禁用某项</p>
</li>
<li><p>非 Boolean 类型：-XX:+&lt;option&gt;=&lt;value&gt;</p>
</li>
<li><p>-XX:+PrintFlagsFinal 输出所有参数的名称和默认值，jinfo 设置运行中的 JVM 参数</p>
</li>
</ul>
</li>
<li><p>堆、栈、方法区相关参数</p>
<p>-Xss&lt;大小&gt;：每个线程栈的大小</p>
<p>-Xms&lt;大小&gt;：初始堆大小</p>
<p>-Xmx&lt;大小&gt;：最大堆大小</p>
<p>-XX:NewSize=&lt;大小&gt;：年轻代大小</p>
<p>-XX:MaxNewSize=&lt;大小&gt;：年轻代最大大小</p>
<p>-XX:NewRatio=&lt;比例&gt;：老年代和新生代比值，默认为 2</p>
<p>-XX:SurvivorRatio=&lt;比例&gt;：伊甸园区和幸存者区比例，默认为 8</p>
<p>-XX:+UseAdaptionSizePolicy: 新生代自动分配，默认打开，优先级高于 SurvivorRatio</p>
<p>-XX:MaxTenuringThreshold=&lt;大小&gt;：新生代每次 MinorGC 之后还存活的对象年龄 +1，大于此年龄收到老年代，默认为 15</p>
<p>-XX:+PrintTenuringDistribution：每次 MinorGC 之后打印幸存者区对象的年龄分布</p>
<p>-XX:MetaspaceSize=&lt;大小&gt;：元空间大小</p>
<p>-XX:MaxMetaspaceSize=&lt;大小&gt;：元空间最大小</p>
</li>
<li><p>OOM 相关参数</p>
<p>-XX:+HeapDumpOnOutOfMemoryError：内存出现 OOM 时，生成 Heap 转储文件以便后续分析</p>
<p>-XX:+HeapDumpBeforeFullGC：FullGC 之前转储</p>
<p>-XX:HeapDumpPath=&lt;路径&gt;：转储文件位置</p>
<p>-XX:OnOutofMemory=&lt;可执行文件&gt;：当 OOM 之后执行</p>
</li>
<li><p>垃圾回收器相关参数</p>
<p>-XX:+UseSerialGC 新生代使用 SerialGC，老年代使用 SerialOldGC，SerialGC 是 Client 模式下默认的回收器</p>
<p>-XX:+UseParNewGC 新生代使用 ParNewGC，老年代不受影响</p>
<p>-XX:+UseParallelGC 新生代使用 ParallelGC，老年代使用 ParallelOldGC，JDK8 默认</p>
<p>-XX:ParallelGCThreads=&lt;个数&gt; 设置年轻代并行回收器的线程数</p>
<p>-XX:MaxGCPauseMillis=&lt;秒数&gt; 设置 GC 最大 STW 时间</p>
<p>-XX:GCTimeRatio=&lt;比例&gt; 垃圾回收时间与总时间的占比，用来衡量吞吐量，默认 99，范围 （0，100）</p>
</li>
<li><p>GC 日志相关</p>
<p>-XX:+PrintGC/-XX:+PrintGCDetails 打印日志</p>
<p>-XX:+PrintGCTimeStamp/-XX:+PrintGCDateStamp 打印日志时间戳和前面的配合使用</p>
<p>-XX:+PrintHeapAtGC 每次 GC 前后 打印堆信息</p>
<p>-X:Loggc:&lt;文件&gt; 输出到文件</p>
</li>
<li><p>其他参数</p>
<p>-XX:+DoEscapeAnalySis 开启逃逸分析</p>
<p>-XX:+UseBiasedLock 开启偏向锁</p>
<p>-XX:+UseTLAB 开启 TLAB，默认打开</p>
<p>-XX:+PrintTLAB 打印 TLAB 的使用情况</p>
<p>-XX:TLABSize 设置 TLAB 大小</p>
</li>
</ol>
<h2 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h2><p><a href="https://gceasy.io">GCEasy</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC 并发编程</title>
    <url>/blog.github.io/2022/04/06/JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>上下文切换原因</code></p>
<ol>
<li><p>时间片用完</p>
</li>
<li><p>垃圾回收</p>
</li>
<li><p>有更高线程优先级需要运行</p>
</li>
<li><p>线程自己调用了 sleep yiled join park lock synchronized 方法</p>
</li>
</ol>
<p>当发生上下文切换时操作系统会保存当前线程状态（PC 寄存器、栈帧信息）并恢复另一个，频繁切换上下文会影响性能。</p>
<p><code>sleep()</code></p>
<ol>
<li><p>调用 sleep 线程会让线程进入 TIMED_WAITING</p>
</li>
<li><p>其他线程调用 interrupt() 方法会打断正在睡的线程，打断的是睡眠，抛出 InterruptedException 异常</p>
</li>
<li><p>睡眠结束后的线程未必会立即执行</p>
</li>
<li><p>建议使用 TimeUnit 的 sleep，可读性更好</p>
</li>
</ol>
<p><code>yiled()</code></p>
<p>让线程从 Running 变成 Runnable 状态，具体实现依赖操作系统的任务调度，但还是有机会继续执行，而 sleep() 的线程处于 TIMED_WAITING，并不会调度到 sleep() 的线程</p>
<p><code>join()</code></p>
<p>等待某个线程运行结束，要等待的线程进入 WAITING</p>
<p><code>interrupt()</code></p>
<p>打断 join wait sleep 的线程之后的被打断线程的打断标记为 false，而正常运行的线程被打断的话只会把打断标记设为 true，相当于只是告知了有人要打断我，但结束与否还得看我自己</p>
<p>interrupt() 的应用：两阶段终止模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 重新设置打断标记</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打断 park()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            <span class="comment">// 打断标记为 true 的线程只能 park 一次，要想再 park 只好再清除打断标记</span></span><br><span class="line">            System.out.println(<span class="string">&quot;打断标记为&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            System.out.println(<span class="string">&quot;打断标记为&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>非守护线程结束了守护线程就算没执行完也会强制结束，垃圾回收器就是一种守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="comment">// 把 t1 设置为守护线程，这样一旦 main 线程结束则强制结束 t1 线程</span></span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java-线程的六种状态源码"><a href="#Java-线程的六种状态源码" class="headerlink" title="Java 线程的六种状态源码"></a>Java 线程的六种状态源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &#123;<span class="doctag">@code</span> Object.wait()&#125;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> Object.notify()&#125; or &#123;<span class="doctag">@code</span> Object.notifyAll()&#125; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &#123;<span class="doctag">@code</span> Thread.join()&#125;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="共享模型"><a href="#共享模型" class="headerlink" title="共享模型"></a>共享模型</h3><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>临界区：一块代码去如果存在堆共享资源的对线程读写操作，则该代码块为临界区。</p>
<p>竞态：多个线程在临界区执行，由于代码执行序列的不同导致结果不可预测，则称之为发生了竞态</p>
<p><code>竞态解决方案：</code></p>
<ol>
<li><p>阻塞式：synchronized、Lock</p>
</li>
<li><p>非阻塞式：原子变量</p>
</li>
</ol>
<p><code>线程安全分析</code></p>
<ol>
<li><p>成员变量、静态变量，如果没有共享则线程安全，共享了只有读操作也线程安全，读写都有则线程不安全</p>
</li>
<li><p>局部变量，局部变量线程安全，但其引用的对象未必安全，如果局部变量引用的对象没有逃离方法作用范围则线程安全，否则需要考虑线程安全问题</p>
</li>
</ol>
<p>常用的 spring boot 增删查改方法是单例的，但是要么不涉及成员变量要么不涉及写操作，因此是线程安全的</p>
<p><code>Monitor</code></p>
<p>由 JVM 知道对象头（ 8 个字节）由 mark word 和 kclass word 组成，数组对象的对象头还多一个 array length, mark word 遇到 synchronized 会指向一个由操作系统提供的 Monitor 对象，Monitor 对象有 owner 属性指向该锁属于哪个线程，再来的线程会先自旋几次（万一锁被释放，自旋适合多核 CPU ）再进入 Monitor 对象的 entryList 队列中等待并且线程状态变为 Blocked。一个锁对应一个 Monitor，不加 synchronized 就不关联 Monitor。当拥有 Monitor 的线程发现条件不满足时可以 wait() 方法进入 Monitor 的waitSet，当其他获得 Owner 当线程 notify() 时从 waitSet 出来重新加入 entryList 竞争，notify() 随机唤醒一个，notifyAll() 唤醒所有</p>
<p><code>synchronized 优化</code></p>
<p>对象头格式：<br><img src="/blog.github.io/2022/04/06/JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1.png"></p>
<p>没有竞态时，偏向锁是打开的，当前线程结束后再来一个线程会膨胀为轻量级锁，假设此时新来的线程没有结束又来一个线程则发生竞态膨胀为重量级锁，轻量级锁和偏向锁对开发者来说并不可见</p>
<p>偏向锁默认开启且有延迟，并且偏向锁还是有机会重新偏向的，阈值是 20 次</p>
<p>调用 hashCode、wait/notify 也会禁用禁用偏向锁</p>
<p>某些情况下会进行锁消除</p>
<p><code>wait/notify</code></p>
<p>sleep() 既不需要与 synchronized 配合也不会释放锁，wait() 需要synchronized也会释放锁</p>
<h5 id="锁膨胀总结"><a href="#锁膨胀总结" class="headerlink" title="锁膨胀总结"></a>锁膨胀总结</h5><p>HotSpot 虚拟机新建对象默认是不加锁的，4 秒后加偏向锁给对象，假设有 A B C 三个线程，当遇到 synchronized，假设此时只有 A 线程在执行则偏向 A，并把 A 的线程 id 赋予对象头的 MARK，A 线程执行完后还是偏向 A，当 A 执行完了假设 B 又来了此时膨胀为轻量级锁，当 B 执行完此时并不会膨胀为重量级锁，当 B 执行过程中又来了 C 则先 CAS 自旋再膨胀为重量级锁。</p>
<h5 id="保护性暂停-Guarded-Suspension-模式"><a href="#保护性暂停-Guarded-Suspension-模式" class="headerlink" title="保护性暂停(Guarded Suspension)模式"></a>保护性暂停(Guarded Suspension)模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> T res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getMes</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> pastedTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitTime = timeout - pastedTime;</span><br><span class="line">                <span class="keyword">if</span> (pastedTime &gt;= timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                pastedTime = System.currentTimeMillis() - begin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMes</span><span class="params">(T res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.res = res;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuardedObject</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> People().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer id : MailBox.getIds()) &#123;</span><br><span class="line">            <span class="keyword">new</span> Postman(id, <span class="string">&quot;消息&quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject&lt;String&gt; guardedObject = MailBox.creatGuardedObject();</span><br><span class="line">        String mes = guardedObject.getMes(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(mes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Postman</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Postman</span><span class="params">(<span class="keyword">int</span> id, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject&lt;String&gt; guardedObject = MailBox.getGuardedObject(id);</span><br><span class="line">        guardedObject.sendMes(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailBox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&lt;String&gt;&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">productId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id++;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject&lt;String&gt; <span class="title">getGuardedObject</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GuardedObject&lt;String&gt; <span class="title">creatGuardedObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GuardedObject&lt;String&gt; guardedObject = <span class="keyword">new</span> GuardedObject&lt;&gt;(productId());</span><br><span class="line">        map.put(guardedObject.getId(), guardedObject);</span><br><span class="line">        <span class="keyword">return</span> guardedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title">getIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=orange >说明：</font></p>
<p>保护性暂停(Guarded Suspension)模式是让一个线程等待另一个线程的结果。java中的join、Future、FutureTask均采用了该模式实现。</p>
<p><code>park()/unpark()</code></p>
<p>可以先 unpark() 再 park()，反之亦可</p>
<p><code>ReentrantLock</code></p>
<p>和 synchronized 对比：</p>
<ol>
<li><p>可中断（lockInterruptibly()）</p>
</li>
<li><p>可以设置超时时间（tryLock(long timeout, TimeUnit unit)）</p>
</li>
<li><p>可设置公平锁（ReentrantLock(boolean fair)）</p>
</li>
<li><p>支持多个条件变量（Condition#await()）</p>
</li>
</ol>
<h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><blockquote>
<p>JMM/Java Memory Model 即内存模型，定义了主存（共享内存）、工作内存（局部变量）的抽象概念，底层对应了 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。主要体现包括原子性（上一章）、可见性、有序性</p>
</blockquote>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>每一个线程都有共享变量的副本在其工作缓存中，假设一个线程改了某个变量的值，另一个线程还是会读副本中的原值，这就发生了可见性问题</p>
<p>volatile 用来修饰成员变量和静态变量，能避免线程从它的工作缓存中获取共享变量的值，必须到主存中获取它的值，线程操作 volatile 都是直接操作主存</p>
<p>synchorized 也能保证共享变量的可见性</p>
<p>两阶段终止模式改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行监控&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断 sleep&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stop = <span class="keyword">true</span>;</span><br><span class="line">            t1.interrupt();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>JVM 会在不影响执行结果的情况下通过重排序和组合来实现指令级的并行，但是指令重排在多线程的条件下会影响正确性</p>
<p>volatile 可避免重排序，synchronized 可以同时保证原子性、可见性、有序性（在共享变量完全由 synchronized 管理的情况下保证有序性，synchronized 里面还是会重排序，比如单例懒汉模式的<a href="/blog.github.io/2022/04/03/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#dcl">双重检查</a>）</p>
<p>volatile 可见性与有序性原理：</p>
<ul>
<li><p>保证可见性</p>
<ol>
<li><p>写屏障保证在 volatile 之前的对共享变量之前的改动都同步到主存中</p>
</li>
<li><p>读屏障保证在这之后对共享变量的读取加载的是主存中的最新数据</p>
</li>
</ol>
</li>
<li><p>保证有序性</p>
<ol>
<li><p>写屏障保证在指令重排时不会将屏障之前的代码排在写屏障之后</p>
</li>
<li><p>读屏障保证在指令重排时不会将屏障之后的代码排在读屏障之前</p>
</li>
</ol>
</li>
</ul>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>CAS(compore and set) 和 volatile 可以实现无锁并发，适合线程少 CPU 核心多的情况</p>
<p>CAS 可认为是原子操作，底层汇编不同处理器不同系统有不同的实现，主要是 lock 和 cmpxchgq 指令起作用，加锁缓存行/总线</p>
<p>CAS 基于乐观锁的思想，不怕其他线程修改，就算改了也没关系，继续重试而已，而 synchronized 基于悲观锁思想，但是使用 CAS 如果竞争激励，重试必然频繁发生，效率反而会低</p>
<h5 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h5><p>AtomicInteger AtomicLong AtomicBoolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 内部已经实现 CAS 操作</span></span><br><span class="line">        System.out.println(atomicInteger.getAndAdd(<span class="number">100</span>));</span><br><span class="line">        atomicInteger.updateAndGet(operand -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> operand * <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(atomicInteger.get()); <span class="comment">//2000</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev = get(), next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> haveNext = <span class="keyword">false</span>;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveNext)</span><br><span class="line">            next = updateFunction.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (weakCompareAndSetVolatile(prev, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        haveNext = (prev == (prev = get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h5><p>AtomicReference AtomicStampReference(避免 ABA 问题)</p>
<h5 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h5><h5 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h5><p>AtomicReferenceFieldUpdater AtomicIntegerFieldUpdater AtomicLongFieldUpdater </p>
<p>要更新的属性必须 volatile 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        updater.compareAndSet(student, <span class="keyword">null</span>, <span class="string">&quot;shaka&quot;</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="缓存伪共享"><a href="#缓存伪共享" class="headerlink" title="缓存伪共享"></a>缓存伪共享</h5><p>CPU 是以缓存行为存取单位的，一个缓存行 64 个字节，假设有一个双核 CPU，去修改位于同一个缓存行的两个数据 x 和 y，两个核心都有自己的单独的缓存行，因此会把主存中的数据各拷贝一份，假设核心一修改了 x，根据 mesi 协议，会造成核心二缓存行中的两个数据都失效，反之亦然，因此造成了伪共享，解决方案是填充空位使两个数据位于不同的缓存行，这就是 Contended 注解的作用</p>
<h5 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h5><p>提供了非常底层的操作内存、线程的方法，该对象只能通过反射获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义原子整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfAtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = UnSafeUtil.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset(SelfAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = value;</span><br><span class="line">            <span class="keyword">int</span> next = pre - amount;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, pre, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnSafeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><p>数量有限的同一类对象</p>
<p>体现： 包装类、数据库连接池、线程池、String、BigDecimal</p>
<p>final 也是通过屏障实现的</p>
<h4 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h4><h5 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列满了条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列为空条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入&quot;</span>);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列&quot;</span> + t);</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T t,<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">long</span> nanos = timeUnit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待加入&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;加入任务队列&quot;</span> + t);</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="keyword">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加入任务队列&quot;</span> + task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolOfShaka</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolOfShaka</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">long</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> capacity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> BlockingQueue&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = queue.take(<span class="number">1</span>,TimeUnit.SECONDS)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                workers.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                Worker worker = <span class="keyword">new</span> Worker(task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolOfShaka threadPoolOfShaka = <span class="keyword">new</span> ThreadPoolOfShaka(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="number">1</span>, (queue, task) -&gt; &#123;</span><br><span class="line"><span class="comment">//            queue.put(task,1000,TimeUnit.MILLISECONDS); // 超时等待</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;fff&quot;); // 放弃</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            threadPoolOfShaka.exe(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><h5 id="七个参数："><a href="#七个参数：" class="headerlink" title="七个参数："></a>七个参数：</h5><ul>
<li><p>int corePoolSize 核心线程数</p>
</li>
<li><p>int maximumPoolSize 最大线程数</p>
</li>
<li><p>long keepAliveTime + TimeUnit unit 救急线程的存活时间</p>
</li>
<li><p>BlockingQueue<Runnable> workQueue 任务队列</p>
</li>
<li><p>ThreadFactory threadFactory 线程工厂，用来创建新线程，起个好名字</p>
</li>
<li><p>RejectedExecutionHandler handler 处理被拒绝的任务</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy;//丢弃任务并抛出RejectedExecutionException异常。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy;//也是丢弃任务，但是不抛出异常。 </p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy;//由调用线程处理该任务 </p>
</li>
</ul>
</li>
<li><p>核心线程先处理，不够的放任务队列，任务队列满了再放最大线程减核心线程的救急线程，救急线程空闲超时以后销毁</p>
</li>
</ul>
<h5 id="固定大小的线程池"><a href="#固定大小的线程池" class="headerlink" title="固定大小的线程池"></a>固定大小的线程池</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors 的静态方法提供，其他一样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                        poolNumber.getAndIncrement() +</span><br><span class="line">                        <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认拒绝策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="带缓存的线程池"><a href="#带缓存的线程池" class="headerlink" title="带缓存的线程池"></a>带缓存的线程池</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange >说明：</font></p>
<p>适合任务比较密集但每个线程执行时间较短的情况</p>
<h5 id="但线程线程池"><a href="#但线程线程池" class="headerlink" title="但线程线程池"></a>但线程线程池</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>线程数固定为 1，多个任务排队执行，即使线程因为失败而终止也会建一个新线程</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    Future&lt;String&gt; future = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shaka&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = threadPool.invokeAll(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shaka1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shaka2&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    String s = threadPool.invokeAny(Arrays.asList(() -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shaka1&quot;</span>;</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shaka2&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建合适数量的线程"><a href="#创建合适数量的线程" class="headerlink" title="创建合适数量的线程"></a>创建合适数量的线程</h5><ol>
<li><p>CPU 密集型：核数 + 1</p>
</li>
<li><p>I/O 密集型：核数 * 期望值利用率 * 总时间 / CPU 计算时间</p>
</li>
</ol>
<h5 id="ScheduledExecutorService-及线程池异常处理"><a href="#ScheduledExecutorService-及线程池异常处理" class="headerlink" title="ScheduledExecutorService 及线程池异常处理"></a>ScheduledExecutorService 及线程池异常处理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    threadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;shaka&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务中自己处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    threadPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;shaka&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Future 处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    Future&lt;Integer&gt; future = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h5><p>JDK1.7 加入，体现了分治思想，适用于能够进行拆分的 CPU 密集型运算，默认会创建与核数相同的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    Integer invoke = forkJoinPool.invoke(<span class="keyword">new</span> MyTask(<span class="number">10</span>));</span><br><span class="line">    System.out.println(invoke);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask(n - <span class="number">1</span>);</span><br><span class="line">        task.fork(); <span class="comment">// 让一个线程区执行</span></span><br><span class="line">        <span class="keyword">return</span> n+task.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aqs"><a href="#aqs" class="headerlink" title="aqs"></a>aqs</h4><blockquote>
<p>aqs（AbstractQueuedSynchronizer） 的基本原理为 CAS 自旋 加 park，当线程交替执行时由于没有切到内核态调用 OS 对应 API 只在 JVM 层面执行因此速度很快，JDK1.6 以后 synchronized 锁优化轻量级锁偏向锁速度也有显著提高，但是 aqs 更加灵活</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义锁（不可重入）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MySync mySync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步器类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mySync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        mySync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mySync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RW</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.object = object;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="orange">注意:</font></p>
<p>读锁不支持条件变量，重入时降级支持（写-&gt;读）升级不支持</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>限制能访问共享变量的线程上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;玩啊玩&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一份&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第二份&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待完成。。。。&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h4><h5 id="遗留的"><a href="#遗留的" class="headerlink" title="遗留的"></a>遗留的</h5><p>HashTable 和 Vector</p>
<h5 id="修饰的"><a href="#修饰的" class="headerlink" title="修饰的"></a>修饰的</h5><p>Collections 的 synchronizedXXX 方法</p>
<h5 id="JUC-安全集合"><a href="#JUC-安全集合" class="headerlink" title="JUC 安全集合"></a>JUC 安全集合</h5><ol>
<li><p>Blocking</p>
</li>
<li><p>CopyOnWrite</p>
</li>
<li><p>Concurrent</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 优化</title>
    <url>/blog.github.io/2022/04/18/MySQL-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="/blog.github.io/2022/04/18/MySQL-%E4%BC%98%E5%8C%96/1.png"></p>
<p>组成：</p>
<ol>
<li><p>连接池</p>
</li>
<li><p>管理服务和工具组件</p>
</li>
<li><p>存储引擎</p>
</li>
<li><p>文件系统</p>
</li>
</ol>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><blockquote>
<p>存储数据、建立索引、更新查询等技术等实现方式，MySQL 支持插件式索引，5.5 以后默认 InnoDB</p>
</blockquote>
<ol>
<li><p>查看支持的引擎：SHOW engines;</p>
</li>
<li><p>查看默认：SHOW variables LIKE ‘%storage_engine%’;</p>
</li>
<li><p>InnoDB vs MyISAM</p>
<p> InnoDB 支持事务、行锁（高并发）、外键 MyISAM 支持表锁不支持事务和外键，优势是查询速度快</p>
</li>
<li><p>MEMORY vs MERGE </p>
<p> MEMORY 存储在 RAM 中，MERGE 是多张 MyISAM 的集合</p>
</li>
</ol>
<h3 id="SQL-优化步骤"><a href="#SQL-优化步骤" class="headerlink" title="SQL 优化步骤"></a>SQL 优化步骤</h3><ol>
<li><p>查询 SQL 执行频率</p>
<p> <code>SHOW [GLOBAL|SESSION] STATUS LIKE [&#39;Com_______&#39;|&#39;InnoDB_rows_%&#39;];</code></p>
</li>
<li><p>定位低效率 SQL</p>
<ul>
<li><p>慢查询日志</p>
</li>
<li><p>SHOW processlist;</p>
</li>
</ul>
</li>
<li><p>分析 explain、show profiles、trance</p>
</li>
</ol>
<h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><p>复合避免索引失效</p>
<ol>
<li><p>全值匹配，生效</p>
</li>
<li><p>最左前缀法则，生效，不包含最左列开始或者跳过中间的不生效，跳过一个只走左边索引</p>
</li>
<li><p>范围查询右边的列不走索引</p>
</li>
<li><p>不要在索引字段进行运算操作，否则失效</p>
</li>
<li><p>字符串不加单引号，失效</p>
</li>
<li><p>尽量使用覆盖索引，而不是 select *，回表查询效率低</p>
</li>
<li><p>or 分隔的条件一个有索引一个么有则索引失效</p>
</li>
<li><p>like 查询 % 加前面，失效，通过覆盖索引解决</p>
</li>
<li><p>全表扫描比索引快时，失效</p>
</li>
<li><p>IS NULL 和 IS NOT NULL 有时失效，绝大部分情况为 1 个值走全表比走索引快就不走索引,和 9 一样</p>
</li>
<li><p>in 走索引，not in 失效</p>
</li>
<li><p>尽量选择复合索引少用单例索引，多个单列索引数据库会选择一个最优的</p>
</li>
</ol>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><ol>
<li><p>大量插入使用 load 导入时，主键有序效率高，还可以导入时先关闭唯一性校验、手动提交事务来进一步提高效率</p>
</li>
<li><p>insert 多行合成一行，大量 insert 前事务改为手动并分段提交，按主键顺序 insert 都可以提高效率</p>
</li>
<li><p>order by 优化</p>
<ul>
<li><p>直接通过索引返回不回表，类似覆盖索引，using index 效率高，而 using filesort 效率低</p>
</li>
<li><p>多字段排序有升有降是 using filesort，同时排序字段和索引字段顺序要一致，否则也是 using filesort</p>
</li>
<li><p>filesort 两次扫描算法效率高内存开销大，一次扫描算法效率低开销低，可适当增大排序区大小</p>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>group by 和 order by 一样也可以使用索引，同时使用 order by null 禁止 group by 的默认排序提高效率</p>
</li>
<li><p>少用子查询而使用 join</p>
</li>
<li><p>or 的所有字段应该都有索引否则索引失效效率低，还可以使用 union 代替 or</p>
</li>
<li><p>limit 排序优化：使用索引完成排序分页操作然后回表查询其他字段</p>
</li>
<li><p>使用 SQL 提示， use index、ignore index 和 force index</p>
</li>
</ol>
<h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h3><ol>
<li><p>使用连接池</p>
</li>
<li><p>减少对 MySQL 的访问，能一次获取的数据就不要分两次查询，还可以增加 cache 层（redis 等）</p>
</li>
<li><p>负载均衡</p>
</li>
</ol>
<h3 id="查询缓存优化"><a href="#查询缓存优化" class="headerlink" title="查询缓存优化"></a>查询缓存优化</h3><p>缓存失效：</p>
<ol>
<li><p>查询语句不完全一致，包括大小写</p>
</li>
<li><p>不使用任何表查询语句</p>
</li>
<li><p>包含一些不确定的</p>
</li>
<li><p>查询系统数据库</p>
</li>
<li><p>在函数、触发器或事件的主体内执行的查询</p>
</li>
<li><p>表更改</p>
</li>
</ol>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>原则：</p>
<ol>
<li><p>尽可能把更多内存分配给 MySQL 做缓存</p>
</li>
<li><p>MyISAM 需要给操作系统预留更多空间做缓存</p>
</li>
<li><p>排序区、连接区等缓存是每个数据库会话专用的，要根据最大连接数合理分配</p>
</li>
</ol>
<p>MySQL 优化：</p>
<p>MySQL 使用 key_buffer 缓存索引块，数据块完全依赖系统 IO 缓存，key_buffer_size 设置索引块缓存大小。如果需要全表扫描，可适当提高 read_buffer_size 大小，read_buffer_size 增大排序区大小，后两个为会话独有。</p>
<p>InnoDB 优化：</p>
<p>InnoDB 有自己的缓存区，可同时缓存数据块和索引块，innnodb_buffer_pool_size 调整缓存区大小，innnodb_log_buffer_size 设置日志缓存大小。</p>
<h3 id="并发参数"><a href="#并发参数" class="headerlink" title="并发参数"></a>并发参数</h3><p>max_connections 最大并发连接数</p>
<p>back_log 积压请求栈大小</p>
<p>table_open_cache 可打开表缓存的数量</p>
<p>thread_cache_size MySQL 客户服务缓存线程数</p>
<p>innodb_lock_wait_timeout 行锁等待时间</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>按粒度：行锁、页面锁、表锁，粒度依次增大</p>
<p>按操作：读锁、写锁</p>
<h4 id="MyISAM-锁"><a href="#MyISAM-锁" class="headerlink" title="MyISAM 锁"></a>MyISAM 锁</h4><p>执行查询前自动给所有表加读锁，更新前，给涉及的表加写锁，无需人为干预。手动加解锁：[lock|unlock] table xxx [read｜write]</p>
<p>MyISAM 读写锁调度以写优先，因此 MyISAM 不适合作为以写为主的表都储存引擎</p>
<h4 id="InnoDB-锁"><a href="#InnoDB-锁" class="headerlink" title="InnoDB 锁"></a>InnoDB 锁</h4><p>行锁特点：开销大，加锁慢，锁粒度小，发生冲突概率低，并发度高。</p>
<p>InnoDB 对于普通查询语句不回加任何锁，而对于更新操作，会自动给涉及数据加写锁。手动加读锁：lock in share mode，手动加写锁：for update</p>
<p>不通过索引检索行锁自动升级为表锁</p>
<p>使用范围检索时在范围内却不存在的数据 InnoDB 也会为其加锁，是为间隙锁</p>
<p>查看行锁征用情况：show status like ‘innodb_row_lock’</p>
<p>优化建议：</p>
<ol>
<li><p>避免行锁升级为表锁</p>
</li>
<li><p>合理设计索引，尽量缩小锁的范围</p>
</li>
<li><p>减少索引条件及范围，避免间隙锁</p>
</li>
<li><p>控制事务大小，少锁几行，尽可能使用较低隔离级别</p>
</li>
</ol>
<h3 id="常用-SQL-技巧"><a href="#常用-SQL-技巧" class="headerlink" title="常用 SQL 技巧"></a>常用 SQL 技巧</h3><p>编写顺序：select、from、join、where、group by、having、order by、limit</p>
<p>执行顺序：from、on、join、where、group by、having、select、order by、limit</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol>
<li><p>错误日志，查看位置：show variables like ‘log_error%’;</p>
</li>
<li><p>binlog(默认关闭)</p>
<p> 格式：</p>
<p> STATEMENT：记录 SQL 语句。主从复制时，从库会解析为原 SQL 并执行一次</p>
<p> ROW：记录每一行的数据变更</p>
<p> MIXED：目前默认，结合 STATEMENT 和 ROW 各自的特点，默认 STATEMENT，特殊情况下 ROW</p>
</li>
<li><p>查询日志（默认关闭）</p>
</li>
<li><p>慢查询日志，记录了所有执行时间超过 long_query_time 并且扫描记录数不小于 min_examined_row_limit 的所有 SQL 语句日志</p>
</li>
<li><p>事务日志（存储引擎生成的日志）</p>
<p> REDO LOG：重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性</p>
<p> UNDO LOG：回滚日志，回滚行记录恢复到某个特定版本，用来保证事务的一致性、原子性</p>
<p> 事务的隔离性由锁实现</p>
<p> 重做日志和回滚日志都可以看作是一种恢复操作，重做日志记录的是物理磁盘的页记录操作，主要是为了保证记录的可靠性，而回滚日志记录的是逻辑操作日志，比如对某一行进行 insert 则反向记录一条 delete，主要用于事务的回滚和一致性非锁定读</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 设计模式</title>
    <url>/blog.github.io/2022/04/03/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><p><code>一般关联关系</code></p>
<p>单向关联：用带箭头的指向被关联类的实线表示</p>
<p>双向关联：用实线表示</p>
<p>自关联：带箭头的指向自己的实线表示</p>
<p><code>聚合关系</code></p>
<p>聚合关系是强关联关系，成员对象是整体对象的一部分，但成员对象也可以单独存在，用带空心菱形的实线表示</p>
<p><code>组合关系</code></p>
<p>组合是更强烈的聚合，成员不可以单独存在，用带实心菱形的实线表示</p>
<p><code>依赖关系</code></p>
<p>耦合度最弱的一种关联方式，是临时性的关联，在代码中通过局部变量、方法参数或静态方法调用来调用被依赖类的某些方法完成某些职责，用带箭头的虚线表示，指向被依赖类</p>
<p><code>继承关系</code></p>
<p>带实心三角的实线表示，子类指向父类</p>
<p><code>实现关系</code></p>
<p>带空心三角的虚线表示，实现类指向接口</p>
<h3 id="软件设计六原则："><a href="#软件设计六原则：" class="headerlink" title="软件设计六原则："></a>软件设计六原则：</h3><blockquote>
<p>为了提高软件系统的可维护性、可复用性 增加可扩展性和灵活性</p>
</blockquote>
<ol>
<li><p>开闭原则</p>
<p> 对扩展开放，对修改关闭，在需要扩展的时候不去修改源代码，实现热插拔，要达到这样的效果需要使用接口和抽象类</p>
</li>
<li><p>里氏替换原则</p>
<p> 父类可以出现的地方子类也可以出现，通俗来说就是子类可以扩展父类功能但尽量不要重写父类的方法  </p>
</li>
</ol>
<ol start="3">
<li><p>依赖倒转原则</p>
<p> 高层模块不应该依赖低层模块，两者应该依赖其抽象，简单说就面对抽象进行编程。</p>
</li>
<li><p>接口隔离原则</p>
<p> 客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小接口之上。</p>
</li>
<li><p>迪米特法则</p>
<p> 只和认识的人说话，不和陌生人说话。当两个软件无须直接通信，那么不应该发生直接调用，而是通过第三方调用，目的是为了降低耦合度。</p>
</li>
<li><p>合成复用原则</p>
<p> 尽量先使用聚合和组合实现关联关系，其次才考虑用继承实现。</p>
<p> 继承复用虽然简单，但父类对子类来说是透明的，属于「白箱」复用，父类的任何改变都会造成子类的改变，耦合度高，并且从父类继承而来的实现是静态的，限制了复用的灵活性。</p>
<p> 组合/聚合复用将已有对象纳入新对象中，新对象可以调用已有对象的功能。新对象对已有对象细节不知，维护了封装性，属于「黑箱」复用，可以声明抽象降低耦合，并且新对象可以引用和已有对象成分相同的对象，灵活性高</p>
</li>
</ol>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><blockquote>
<p>对象的创建与使用分离使用者不关心对象的创建细节</p>
</blockquote>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>角色：单例类（只能创建一个实例的类）和访问类（使用单例类的类）</p>
<p>饿汉式（静态变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式（静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果方法加上 synchronized 是安全但是效率太差，因为对于读操作是线程安全的而大部分操作又是读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（双重检查）<a id="dcl"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查过滤掉读操作</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查为了保证单例</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式（静态内部类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>第一次加载 Singleton 类时并不会初始化 SINGLETON，只有第一次调 getInstance() 时 JVM 才会加载 SingletonHolder 并初始化 SINGLETON。这样不仅能保证线程安全也可以保证实例的唯一性，并且没有空间浪费（饿汉式会浪费）。是开源项目比较常用的一种单例模式方式。</p>
<p>饿汉式（枚举类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE(<span class="string">&quot;shaka&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SingletonEnum(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>写法简单且是唯一一种不会被破坏的单例模式，极力推荐，破坏单例模式的方式可以序列化反序列化也可以反射创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解决反射破坏单例的解决方案</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不能创建多个对象&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决序列化破坏单例，会自动调用 readObject()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange >说明：</font></p>
<p>解决序列化和反射破坏单例模式的方式</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><del>简单工厂模式</del></h4><p>该模式不属于 23 种设计模式之一，而是一种习惯</p>
<p>角色：抽象产品、具体产品、具体工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSugar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title">instance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;american&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没那种咖啡&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">orderCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = SimpleCoffeeFactory.instance(type);</span><br><span class="line">        coffee.addSugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange >说明：</font></p>
<p>把对象的创建和使用逻辑分离，解除了 CoffeeStore 和具体 Coffee 的耦合，增加新产品还得修改工厂，违背了「开闭原则」</p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><blockquote>
<p>工厂方法模式使一个产品类的实例化延迟到其子类</p>
</blockquote>
<p>角色：抽象产品、具体产品、抽象工厂、具体工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSugar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Coffee <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">orderCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Coffee coffee = coffeeFactory.instance();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCoffeeFactory</span><span class="params">(CoffeeFactory coffeeFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffeeFactory = coffeeFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>只需要知道具体工厂就能创建产品，不必知道创建细节，增加新的工厂类即可创建新产品，无需修改原工厂，满足「开闭原则」，然而每增加一个产品就需要增加一个对应工厂，增加了复杂度</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><blockquote>
<p>为访问类创建一组相关或相互依赖对象的借口，且访问类无需指定所要产品的具体类就能得到同族的不同级别产品</p>
</blockquote>
<p>角色：抽象产品、具体产品、抽象工厂、具体工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSugar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trimisu</span> <span class="keyword">extends</span> <span class="title">Dessert</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提拉米苏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mousse</span> <span class="keyword">extends</span> <span class="title">Dessert</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;慕斯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Coffee <span class="title">produceCoffee</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dessert <span class="title">produceDessert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">produceCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">produceDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItilyDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">produceCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">produceDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Trimisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange >说明：</font></p>
<p>当一个产品族中的多个对象被设计一起工作时，能保证始终使用一个产品族中的对象，但产品族需要新加一个产品时所有工厂都得更改</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote>
<p>用一个已经存在的对象作为原型，通过原型对象复制一个一模一样的新对象</p>
</blockquote>
<p>角色：抽象原型类(Cloneable 接口)、具体原型类（实现Cloneable 接口）、访问类</p>
<p>浅克隆：创建一个新对象，属性和原对象相同，对于非基本数据类型属性，仍指向原对象属性的地址</p>
<p>深克隆：创建一个新对象，属性和原对象相同，对于非基本数据类型属性，也克隆一份。（可使用对象流复制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适用场景：对象的创建复杂性能和安全要求较高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原型对象创建完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Dog) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ts</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        Dog dog1 = dog.clone();</span><br><span class="line">        System.out.println(dog1 == dog); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote>
<p>将复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示</p>
</blockquote>
<p>角色：抽象建造者、具体建造者、指挥者、产品类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(String frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeat</span><span class="params">(String seat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Bike bike = <span class="keyword">new</span> Bike();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">instanceBike</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bike.setFrame(<span class="string">&quot;碳纤维架子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bike.setSeat(<span class="string">&quot;真皮椅子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">instanceBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bike.setFrame(<span class="string">&quot;铝合金架子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bike.setSeat(<span class="string">&quot;塑料椅子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">instanceBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildSeat();</span><br><span class="line">        builder.buildFrame();</span><br><span class="line">        <span class="keyword">return</span> builder.instanceBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builkld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(<span class="keyword">new</span> MobileBuilder());</span><br><span class="line">        Bike bike = director.instance();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造器参数过多时也可以使用建造者模式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String soc;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainborad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Phone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.soc = builder.soc;</span><br><span class="line">        <span class="keyword">this</span>.screen = builder.screen;</span><br><span class="line">        <span class="keyword">this</span>.memory = builder.memory;</span><br><span class="line">        <span class="keyword">this</span>.mainborad = builder.mainborad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String soc;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainborad;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">soc</span><span class="params">(String soc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.soc = soc;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.memory = memory;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">mainborad</span><span class="params">(String mainborad)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainborad = mainborad;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;soc=&#x27;&quot;</span> + soc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainborad=&#x27;&quot;</span> + mainborad + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builkld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone.Builder()</span><br><span class="line">                .soc(<span class="string">&quot;高通&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;12GB&quot;</span>)</span><br><span class="line">                .mainborad(<span class="string">&quot;双板&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><blockquote>
<p>将类或者对象按某种布局组成更大的结构，分为类结构型模式和对象结构型模式，前者采用继承机制来组织类或接口，后者采用聚合或组合来组合对象</p>
</blockquote>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>角色：抽象主题类、真实主题类、代理类</p>
<p>起到一个中介和保护目标对象的作用，将客户端和目标对象分离，降低了一点耦合，还可以扩展目标对象的功能，但是增加了系统复杂度</p>
<ol>
<li><p>静态代理（略）</p>
</li>
<li><p>动态代理</p>
<ul>
<li><p>JDK 动态代理</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由 arthas 得到的代理类原理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">Proxy</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Sellable</span> </span>&#123; <span class="comment">// 继承的接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123; <span class="comment">// 代理对象的使用者调用方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// h 是传过来的 InvocationHandler 对象，m3 为接口方法对象</span></span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.shaka.design_patterns.proxy.Sellable&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sellable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure></li>
<li><p>cglib 动态代理</p>
<p>  可以没接口不能为 final，因为实际生成的是被代理类的子类</p>
</li>
</ul>
</li>
</ol>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<p>将一个类的接口转换成客户希望的另外一种接口，分为类适配器模式和对象适配器模式，前者耦合度高，用的相对较少</p>
</blockquote>
<p>角色：抽象目标、适配者、适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者类接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;TF 卡数据读取&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往 TF 卡写数据&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;SD 卡数据读取&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往 SD 卡写数据&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作。。。&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;</span><br><span class="line">        String s = sdCard.readSD();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        System.out.println(computer.readSD(<span class="keyword">new</span> SDAdapterTF()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange>注意：</font></p>
<p>此为类适配器模式，违背了合成复用原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器修改为对象适配模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title">SDCard</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配器工作。。。&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><blockquote>
<p>不改变现有结构的情况下，动态给对象增加一些职责</p>
</blockquote>
<p>角色：抽象构件、具体构件、抽象装饰、具体装饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象构件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">(Double price, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Double <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体构件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedRice</span> <span class="keyword">extends</span> <span class="title">FastFood</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedRice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">10.0</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体构件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedNoodles</span> <span class="keyword">extends</span> <span class="title">FastFood</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedNoodles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">20.0</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象装饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Garnish</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garnish</span><span class="params">(Double price, String desc, FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(price, desc);</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garnish</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastFood <span class="title">getFastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFastFood</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体装饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Egg</span> <span class="keyword">extends</span> <span class="title">Garnish</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1.0</span>, <span class="string">&quot;加鸡蛋&quot;</span>, fastFood);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FastFood food = <span class="keyword">new</span> Egg(<span class="keyword">new</span> FriedRice());</span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost());</span><br><span class="line"></span><br><span class="line">        food = <span class="keyword">new</span> Egg(food);</span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=orange>说明：</font></p>
<p>装饰者模式比继承具有更灵活的拓展性，遵循开闭原则，继承是静态的附加责任，装饰者是动态的附加责任</p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote>
<p>将定义和实现分离，使它们可以独立变化。适用于存在俩变化维度且两个维度都需要扩展，防止因继承造成的类爆炸。</p>
</blockquote>
<p>角色：抽象化角色、扩展抽象化角色、实现化角色、具体实现化角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVIVideoFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;解码视频文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MP4VideoFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;解码视频文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatingSystem</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展抽象化角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">extends</span> <span class="title">OperatingSystem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Windows</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OperatingSystem system = <span class="keyword">new</span> Windows(<span class="keyword">new</span> AVIVideoFile());</span><br><span class="line">        system.play(<span class="string">&quot;1.avi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><blockquote>
<p>为多个复杂的子系统提供一个一致的接口，从而使子系统更加容易被访问</p>
</blockquote>
<p>角色：外观角色、子系统角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关电视 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开空调&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关空调 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartAP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmartAP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = <span class="keyword">new</span> Light();</span><br><span class="line">        <span class="keyword">this</span>.tv = <span class="keyword">new</span> TV();</span><br><span class="line">        <span class="keyword">this</span>.airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.contains(<span class="string">&quot;wake&quot;</span>)) &#123;</span><br><span class="line">            wake();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.contains(<span class="string">&quot;sleep&quot;</span>)) &#123;</span><br><span class="line">            sleep();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.off();</span><br><span class="line">        light.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.on();</span><br><span class="line">        light.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmartAP smartAP = <span class="keyword">new</span> SmartAP();</span><br><span class="line">        smartAP.say(<span class="string">&quot;hahah, wake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange>说明：</font></p>
<p>降低了子系统和客户之间的耦合度，使子系统用起来更加的方便，但是不符合开闭原则</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><blockquote>
<p>把一组相似的对象当一个单一的整体，依据树形结构组合对象</p>
</blockquote>
<p>角色：抽象根节点、树枝节点、叶子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;透明组合模式：抽象根节点定义了管理成员对象的方法，确保所有构件都有相同的接口，</span></span><br><span class="line"><span class="comment"> * 缺点是是不够安全，因为叶子节点有这些方法没意义但编译通过&lt;p/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全组合模式：没有管理成员对象的方法，缺点是不够透明,不能完全面对抽象编程&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        components.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        components.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent component : components) &#123;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><blockquote>
<p>运用共享技术有效支持大量细粒度对象的复用，共享已经存在的对象大幅度减少需要创建的对象数量</p>
</blockquote>
<p>角色：抽象享元、具体享元、享元工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象享元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;形状：&quot;</span> + getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体享元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体享元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BoxFactory boxFactory = <span class="keyword">new</span> BoxFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoxFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, <span class="keyword">new</span> LBox());</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, <span class="keyword">new</span> Obox());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBox <span class="title">getBox</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoxFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boxFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BoxFactory boxFactory = BoxFactory.getInstance();</span><br><span class="line">        AbstractBox o = boxFactory.getBox(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">        o.display(<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        AbstractBox o1 = boxFactory.getBox(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">        o1.display(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line">        System.out.println(o == o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><blockquote>
<p>用于描述程序在运行时复杂的流程控制，分为类行为模式和对象行为模式，由于组合或聚合关系耦合度比继承关系低，因此对象行为型模式更加灵活，除了模版方法模式和解释器模式其他均属于对象行为型模式</p>
</blockquote>
<h4 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h4><blockquote>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类，使得子类可以在不改变骨架的情况下重新定义某些特定步骤，实现了反向控制</p>
</blockquote>
<p>角色：</p>
<ol>
<li><p>抽象类</p>
<ul>
<li><p>模版方法：定义了算法的骨架，按某种顺序调用基本方法</p>
</li>
<li><p>基本方法：</p>
<ul>
<li><p>抽象方法</p>
</li>
<li><p>具体方法</p>
</li>
<li><p>钩子方法：在抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类   </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模版方法模仿炒菜</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模版方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pourOil();</span><br><span class="line">        heatOil();</span><br><span class="line">        pourVegetables();</span><br><span class="line">        pourSauce();</span><br><span class="line">        fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourVegetables</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;翻炒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FryBaocai</span> <span class="keyword">extends</span> <span class="title">Cook</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加盐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cook cook = <span class="keyword">new</span> FryBaocai();</span><br><span class="line">        cook.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><blockquote>
<p>定义了一系列算法，并将每个算法封装起来，使它们可以互相替换，并且算法的改变不会影响使用算法的客户。</p>
</blockquote>
<p>结构：抽象策略类、具体策略类、环境类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A 策略&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 策略&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环境类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShowMan</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShowMan showMan = <span class="keyword">new</span> ShowMan(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        showMan.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        showMan.setStrategy(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        showMan.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote>
<p>把请求封装为一个对象，将发出请求的责任和执行请求的责任分开，这样两者就可以通过命令对象沟通，这样方便对命令对象进行存储、传递、调用、增加与管理</p>
</blockquote>
<p>结构：抽象命令、具体命令、实现者/接收者、调用者/请求者</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/blog.github.io/2022/05/04/Netty/</url>
    <content><![CDATA[<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="多线程-vs-线程池-vs-selector"><a href="#多线程-vs-线程池-vs-selector" class="headerlink" title="多线程 vs 线程池 vs selector"></a>多线程 vs 线程池 vs selector</h3><ol>
<li><p>多线程的缺点</p>
<ul>
<li><p>内存占用高</p>
</li>
<li><p>上下文切换成本高</p>
</li>
<li><p>只适合连接少的情况</p>
</li>
</ul>
</li>
<li><p>线程池缺点</p>
<ul>
<li><p>阻塞模式下，一个线程只能处理一个 socket</p>
</li>
<li><p>仅适合短链接</p>
</li>
<li><p>综上，线程利用率不高</p>
</li>
</ul>
</li>
<li><p>selector 一个线程管理多个 channel，监听 channel 上的事件，适合连接数特别多，流量低的场景</p>
</li>
</ol>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 基本使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/main/resources/1.txt&quot;</span>).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = fileChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">                log.debug(<span class="string">&quot;读取到&#123;&#125;&quot;</span>, (<span class="keyword">char</span>) b);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 和 ByteBuffer 互相转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种方法会自动切换回读模式</span></span><br><span class="line">    ByteBuffer buffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;shaka0&quot;</span>);</span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.wrap(<span class="string">&quot;shaka1&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    String string = StandardCharsets.UTF_8.decode(buffer).toString();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部解析"><a href="#内部解析" class="headerlink" title="内部解析"></a>内部解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 三个重要属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写切换到读时调用，limit 为读取限制，position 切换为读取位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读切换到写时调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ByteBuffer 有两个子类， DirectByteBuffer 和 HeapByteBuffer, DirectByteBuffer 分配效率低读写效率高，HeapByteBuffer 分配效率高读写低</p>
<h3 id="文件-Channel"><a href="#文件-Channel" class="headerlink" title="文件 Channel"></a>文件 Channel</h3><blockquote>
<p>FileChannel 只能工作在阻塞模式下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/main/resources/1.txt&quot;</span>);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/main/resources/2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// FileChannel 的读写看文件流，FileChannel 比单纯文件流复制效率高</span></span><br><span class="line">        FileChannel channelFrom = fileInputStream.getChannel();</span><br><span class="line">        FileChannel channelTo = fileOutputStream.getChannel();</span><br><span class="line">        <span class="keyword">long</span> size = channelFrom.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">            <span class="comment">// transferTo 一次复制大小限制为 2g，超过 2g 使用这种方法循环复制</span></span><br><span class="line">            left -= channelFrom.transferTo((size - left), left, channelTo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Channel 必须关闭，但文件流的关闭会间接关闭 FileChannel</span></span><br><span class="line">            <span class="keyword">assert</span> fileInputStream != <span class="keyword">null</span>;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            <span class="keyword">assert</span> fileOutputStream != <span class="keyword">null</span>;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* NIO 另一种拷贝方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;src/main/resources/1.txt&quot;</span>);</span><br><span class="line">    Path path2 = Paths.get(<span class="string">&quot;src/main/resources/3.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Files.copy(path, path2,, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="网络-Channel"><a href="#网络-Channel" class="headerlink" title="网络 Channel"></a>网络 Channel</h3><p>accept() 方法和 read() 方法默认都是阻塞的，可以调用SockertChannel &amp;&amp; ServerSocketChannel 的 configureBlocking() 设置为非阻塞的，accept() 方法用来建立连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t5</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 把 accept() 设置为非阻塞</span></span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 把 ServerSocketChannel 注册到 selector,通过 SelectionKey 可以知道哪个 channel 的哪个事件发生</span></span><br><span class="line">    SelectionKey sscKey = serverSocketChannel.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置关注的事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 没有事件发生时会阻塞，防止空转,有未处理的事件也不会阻塞</span></span><br><span class="line">        selector.select();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey selectionKey = keyIterator.next();</span><br><span class="line">            <span class="comment">// 从 selectedKeys 移除处理的 key，事件发生后才会加入到 selectedKeys 集合</span></span><br><span class="line">            keyIterator.remove();</span><br><span class="line">            <span class="comment">// 看看事件是不是 Acceptable</span></span><br><span class="line">            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                <span class="comment">// 处理 accept 事件</span></span><br><span class="line">                SocketChannel socketChannel = channel.accept();</span><br><span class="line">                log.debug(<span class="string">&quot;accept 事件得到到 channel&#123;&#125;&quot;</span>,socketChannel);</span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                <span class="comment">// 把 buffer 作为附件传入</span></span><br><span class="line">                SelectionKey scKey = socketChannel.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 看看事件是不是 Readable</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 从附件中取得 buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    <span class="comment">// 处理 read 事件</span></span><br><span class="line">                    <span class="comment">// 正常断开返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> i = channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;处理正常断开&quot;</span>);</span><br><span class="line">                        selectionKey.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        String s = StandardCharsets.UTF_8.decode(buffer).toString();</span><br><span class="line">                        log.debug(<span class="string">&quot;收到&#123;&#125;&quot;</span>, s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 从 selector 的 key 集合中真正删除 key</span></span><br><span class="line">                    selectionKey.cancel();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t6</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=orange>说明：</font></p>
<p>连接正常或者异常关闭都会触发 read 事件，因此需要从 selector 的 key 集合中真正删除 key；多路复用 Channel 仅适合网络 Channel，当网络 Channel 写数据时限于网络传输能力，Channel 未必时时可写，因此大数据量的写入可关注 write 事件，可写时触发</p>
<h4 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h4><ol>
<li><p>固定长度读取，缺点是浪费带宽</p>
</li>
<li><p>添加分隔符，缺点是效率低</p>
</li>
<li><p>TLV 或者 LTV，即提前分配好类型长度的 Buffer，缺点是如果内容过大影响吞吐量</p>
</li>
</ol>
<p>可以把 Buffer 作为附件关联到 SelectKey </p>
<h3 id="NIO-vs-BIO"><a href="#NIO-vs-BIO" class="headerlink" title="NIO vs BIO"></a>NIO vs BIO</h3><p>stream 和 channel</p>
<ul>
<li><p>stream 不会自动缓冲数据，channel 会利用系统底层的发送接收缓冲区</p>
</li>
<li><p>stream 只支持阻塞 API, channel 阻塞和非阻塞 API都支持，且配合 selector 可以实现多路复用</p>
</li>
<li><p>二者均为全双工，即读写可以同时进行</p>
</li>
</ul>
<h4 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h4><p>当调用 stream 或者 channel 的 read 方法会切换至操作系统内核来完成真正数据的读取，而读取分两个阶段，即等待读取和复制数据阶段。</p>
<p>同步：线程自己去获取某个结果</p>
<p>异步：自己不去获得结果由其他线程送来结果</p>
<p>阻塞 IO，非阻塞 IO 和多路复用都是同步的</p>
<ol>
<li><p>阻塞 IO</p>
<p> 当数据没到，调用 read() 方法切换至内核空间时会阻塞住，数据到了再复制，这里阻塞的是用户程序空间线程</p>
</li>
<li><p>非阻塞 IO</p>
<p> 当数据没到，调用 read() 方法切换至内核空间时会立即返回 0，并由于处于循环中再次调用 read() 方法，数据到了再完成复制数据步骤，并且再复制阶段也是阻塞的，由于一直调用 read 方法会多次在用户空间和内核空间来回切换因此性能并不高</p>
</li>
<li><p>多路复用</p>
<p> 多路复用和阻塞 IO 在等待阶段都是阻塞的，但是阻塞只能一个挨着一个执行等待和复制，而多路复用可以一次 select 返回多个等待结果，然后直接复制</p>
</li>
</ol>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>以发送一个文件到其他机器为例：会先将磁盘拷贝到内核缓存区，接着拷贝到用户缓冲区，再拷贝到 socket 缓冲区，最后再拷贝到网卡，一共发生四次拷贝，且来回切换内核态和用户态，耗费性能。</p>
<p>而 JVM 调用 transforTo 方法则会先切换到内核态拷贝到内核缓存区，然后拷贝到网卡，只往一些 offset 和 length 信息拷贝到 socket 缓冲区，所谓零拷贝是指不拷贝到用户态。</p>
<p>零拷贝只适合小文件</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>EventLoop 本质上是个单线程执行器（同时维护了一个 Selector），里面有 run 方法 channel 上源源不断的 IO 事件</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 register 方法来绑定其中一个 EventLoop，后续这个 Channel 的一系列事件都由该 EventLoop 处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup loopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="comment">// 普通任务/</span></span><br><span class="line">    loopGroup.next().submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;执行任务线程: &#123;&#125;&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;主线程任务执行。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    loopGroup.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;定时执行任务线程: &#123;&#125;&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------</span></span><br><span class="line"><span class="comment">// 处理 IO 事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">    <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 为防止阻塞其他 IO 事件将 handler 抛给一个新的 EventLoopGroup</span></span><br><span class="line">                    channel.pipeline().addLast(group, <span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            log.debug(buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8990</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Future-和-Promise"><a href="#Future-和-Promise" class="headerlink" title="Future 和 Promise"></a>Future 和 Promise</h4><p>JDK Future 只能同步等待任务结果，Netty Future 继承自 JDK Future，可以同步也可以异步等待结果，Promise 是 Netty Future 的扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    NioEventLoopGroup loopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    EventLoop eventLoop = loopGroup.next();</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; future = eventLoop.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/*log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">    // 同步方式</span></span><br><span class="line"><span class="comment">    Integer integer = future.get();</span></span><br><span class="line"><span class="comment">    System.out.println(integer);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步方式</span></span><br><span class="line">    future.addListener(future1 -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;结果&#123;&#125;&quot;</span>, future1.get());</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Promise 就是结果的容器，可以自己主动去放</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(group.next());</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        promise.setSuccess(<span class="number">22</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer integer = promise.get();</span><br><span class="line">            log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>, integer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Handler-amp-PipeLine"><a href="#Handler-amp-PipeLine" class="headerlink" title="Handler &amp; PipeLine"></a>Handler &amp; PipeLine</h4><blockquote>
<p>Channel 是工厂，PipeLine 是流水线，Handler 是流水线上的一道道工序，ByteBuf 是原材料，流水线上有默认的头尾 handler</p>
</blockquote>
<p>入站 handler 从头往后执行，出站 handler 从尾往前执行。上下文的 write 方法从当前位置往头找出站 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试出入站</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ChannelInboundHandlerAdapter h1 = <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;________1&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ChannelInboundHandlerAdapter h2 = <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;________2&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 用来测试出入站的类</span></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(h1, h2);</span><br><span class="line">    <span class="comment">// 模拟入站操作</span></span><br><span class="line">    channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆内存分配效率高，读写效率低，直接内存相反,默认直接内存</span></span><br><span class="line"><span class="comment">// 池化可以重复利用 ByteBuf，4.1 以后非安卓平台默认开启池化</span></span><br><span class="line">ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">ByteBuf heapBuffer = ByteBufAllocator.DEFAULT.heapBuffer();</span><br><span class="line">ByteBuf directBuffer = ByteBufAllocator.DEFAULT.directBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入，调用writeXxx</span></span><br><span class="line">directBuffer.writeCharSequence(<span class="string">&quot;shaka&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>ByteBuf 实现了 ReferenceCounted 接口，里面有释放方法 release(), 在 pipeline 的最后一个 handler 中调用</p>
<p>ByteBuf 的零拷贝体现在 slice() 方法切片和 CompositeByteBuf#addComponents() 方法，并没有将原始数据进行拷贝，只是逻辑切片与结合</p>
<h3 id="黏包半包"><a href="#黏包半包" class="headerlink" title="黏包半包"></a>黏包半包</h3><blockquote>
<p>tcp 传输是可靠的，如果等待每一个请求响应才能返回那这样的串行方式效率太低，因此引用滑动窗口概念，窗口其实就起到一个缓存区的作用，窗口的大小即可同时发送请求的大小，超出窗口的请求要在窗口 ack 后窗口向下滑动才能继续发送。<br>tcp 是流式协议无消息边界因此容易发生黏包半包</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">            <span class="comment">// LTC 解决黏包半包</span></span><br><span class="line">            <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">            , <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    toBuf(buffer, <span class="string">&quot;shaka&quot;</span>);</span><br><span class="line">    channel.writeInbound(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toBuf</span><span class="params">(ByteBuf buffer, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">    <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">    buffer.writeInt(length);</span><br><span class="line">    buffer.writeBytes(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h3><p><code>redis RESP 协议</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以此为例</span><br><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line"></span><br><span class="line">// 实际发送的数据</span><br><span class="line">*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$5\r\nHello\r\n</span><br><span class="line"></span><br><span class="line">// 实际响应的数据</span><br><span class="line">+OK\r\n</span><br></pre></td></tr></table></figure>



<p><code>自定义协议要素</code></p>
<ol>
<li><p>魔数，第一时间判断是否是无效数据包</p>
</li>
<li><p>版本，可以支持协议的升级</p>
</li>
<li><p>序列化方式（json jdk hessian protobuf）</p>
</li>
<li><p>指令类型，是登录、注册、单聊、群聊。。。</p>
</li>
<li><p>请求序号，为了双工通信</p>
</li>
<li><p>正文长度</p>
</li>
<li><p>正文</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 魔数 4 字节</span></span><br><span class="line">        byteBuf.writeBytes(<span class="string">&quot;haka&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 版本 1字节</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 序列化方式 1 字节，0 jdk 1 json</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 指令类型 1 字节</span></span><br><span class="line">        byteBuf.writeByte(message.getMessageType());</span><br><span class="line">        <span class="comment">// 4 个字节</span></span><br><span class="line">        byteBuf.writeInt(message.getSequenceId());</span><br><span class="line">        <span class="comment">// 填充 1 个字节</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream arrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(arrayOutputStream);</span><br><span class="line">        outputStream.writeObject(message);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = arrayOutputStream.toByteArray();</span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">        <span class="comment">// 长度 4个字节</span></span><br><span class="line">        byteBuf.writeInt(length);</span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span> padding = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        byteBuf.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream stream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message msg = (Message) stream.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        list.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> LoggingHandler(), <span class="keyword">new</span> MessageCodec());</span><br><span class="line">        channel.writeOutbound(<span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;shaka&quot;</span>, <span class="string">&quot;1111&quot;</span>, <span class="string">&quot;haka&quot;</span>));</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;shaka&quot;</span>, <span class="string">&quot;1111&quot;</span>, <span class="string">&quot;haka&quot;</span>),</span><br><span class="line">                buf);</span><br><span class="line">        channel.writeInbound(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Sharable 可以看 handler 是否可以共享，无保存状态的可以加该注解,可以共享的 handler 无半包黏包的状态保存问题，可以用来多个 channel 共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequenceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Class&lt;?&gt;&gt; messageClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOGIN_REQUEST_MESSAGE_TYPE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOGIN_RESPONSE_MESSAGE_TYPE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        messageClasses.put(LOGIN_REQUEST_MESSAGE_TYPE, LoginRequestMessage.class);</span><br><span class="line">        messageClasses.put(LOGIN_RESPONSE_MESSAGE_TYPE, LoginResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getMessageClass(<span class="keyword">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">return</span> messageClasses.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LOGIN_REQUEST_MESSAGE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginResponseMessage</span> <span class="keyword">extends</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> String cause;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LOGIN_RESPONSE_MESSAGE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>,<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = channelHandlerContext.alloc().buffer();</span><br><span class="line">        <span class="comment">// 魔数 4 字节</span></span><br><span class="line">        byteBuf.writeBytes(<span class="string">&quot;baga&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 版本 1字节</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 序列化方式 1 字节，0 jdk 1 json</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 指令类型 1 字节</span></span><br><span class="line">        byteBuf.writeByte(message.getMessageType());</span><br><span class="line">        <span class="comment">// 4 个字节</span></span><br><span class="line">        byteBuf.writeInt(message.getSequenceId());</span><br><span class="line">        <span class="comment">// 填充 1 个字节</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jdk 序列化</span></span><br><span class="line">        <span class="comment">/*ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream();</span></span><br><span class="line"><span class="comment">        ObjectOutputStream outputStream = new ObjectOutputStream(arrayOutputStream);</span></span><br><span class="line"><span class="comment">        outputStream.writeObject(message);</span></span><br><span class="line"><span class="comment">        byte[] bytes = arrayOutputStream.toByteArray();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JSON 序列化</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = JSON.toJSONString(message).getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">        <span class="comment">// 长度 4个字节</span></span><br><span class="line">        byteBuf.writeInt(length);</span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">        list.add(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span> padding = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        byteBuf.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="comment">/* ObjectInputStream stream = new ObjectInputStream(new ByteArrayInputStream(bytes));</span></span><br><span class="line"><span class="comment">        Message msg = (Message) stream.readObject();*/</span></span><br><span class="line">        Class&lt;?&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        Message msg = (Message) JSON.parseObject(<span class="keyword">new</span> String(bytes), messageClass);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        list.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">        MessageCodec messageCodec = <span class="keyword">new</span> MessageCodec();</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline</span><br><span class="line">                                <span class="comment">// 半包黏包</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                                <span class="comment">// 日志</span></span><br><span class="line">                                .addLast(loggingHandler)</span><br><span class="line">                                <span class="comment">// 自定义编解码</span></span><br><span class="line">                                .addLast(messageCodec)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, LoginRequestMessage loginRequestMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                       LoginResponseMessage responseMessage;</span><br><span class="line">                                        <span class="keyword">if</span> (loginRequestMessage.getUsername().equals(<span class="string">&quot;shaka&quot;</span>) &amp;&amp; loginRequestMessage.getPassword().equals(<span class="string">&quot;111&quot;</span>)) &#123;</span><br><span class="line">                                            responseMessage = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            responseMessage = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或者密码错误&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        channelHandlerContext.writeAndFlush(responseMessage);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8888</span>);</span><br><span class="line">        channelFuture.sync();</span><br><span class="line">        Channel channel = channelFuture.channel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup loopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">        MessageCodec messageCodec = <span class="keyword">new</span> MessageCodec();</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap().group(loopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline</span><br><span class="line">                                <span class="comment">// 半包黏包</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">                                <span class="comment">// 日志</span></span><br><span class="line">                                .addLast(loggingHandler)</span><br><span class="line">                                <span class="comment">// 自定义编解码</span></span><br><span class="line">                                .addLast(messageCodec)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">                                        LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;shaka&quot;</span>, <span class="string">&quot;111&quot;</span>, <span class="string">&quot;hah&quot;</span>);</span><br><span class="line">                                        ctx.writeAndFlush(message);</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                                        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> LoginResponseMessage) &#123;</span><br><span class="line">                                            LoginResponseMessage responseMessage = (LoginResponseMessage) msg;</span><br><span class="line">                                            log.warn(<span class="string">&quot;&#123;&#125;&quot;</span>,responseMessage);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channelFuture.sync(); <span class="comment">// 阻塞 main 线程直到连接建立完毕</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            log.debug(<span class="string">&quot;连接建立完毕：&#123;&#125;&quot;</span>, channel);</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    String nextLine = scanner.nextLine();</span><br><span class="line">                    System.out.println(nextLine);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(nextLine)) &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;处理关闭。。。。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><blockquote>
<p>客户端通过 BootStrap 的 option() 方法设置参数，服务器端通过 ServerBootStrap 的 option() 方法给 ServerSocketChannel 配置参数，通过 childoption() 方法给 SocketChannel 配置参数</p>
</blockquote>
<ol>
<li><p>连接超时</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                <span class="comment">// 连接超时设置</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9099</span>);</span><br><span class="line">        channelFuture.sync().channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接超时&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SO_BACKLOG</p>
<p> 半连接队列：存放未完成三次握手的 tcp 连接</p>
<p> 全连接队列：存放完成三次握手的 tcp 连接，便于 accept() 处理，免得连接过多一下处理不来</p>
<p> Linux 设置全连接队列：/proc/sys/net/core/somaxconn，设置半连接队列：/proc/sys/net/ipv4/tcp_max_syn_backlog</p>
<p> 当 netty 传入 SO_BACKLOG， 以系统设置和该设置的较小值为准</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">serverBootstrap.group(boss, worker)</span><br><span class="line">        <span class="comment">// 全连接队列设置</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                socketChannel.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(<span class="number">9999</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 原理</title>
    <url>/blog.github.io/2022/04/22/Spring-Boot-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ol>
<li><p>main 方法启动生成一个 SpringApplication 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sources = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">    <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.addConversionService = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.headless = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.additionalProfiles = Collections.emptySet();</span><br><span class="line">    <span class="keyword">this</span>.isCustomEnvironment = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.lazyInitialization = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">    <span class="keyword">this</span>.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 推断 WEB 应用类型(NONE、REACTIVE、SERVLET)</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 从 spring.factories 中获取 BootstrapRegistryInitializer 对象</span></span><br><span class="line">    <span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    <span class="comment">// 从 spring.factories 中获取 ApplicationContextInitializer 对象</span></span><br><span class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 从 spring.factories 中获取 ApplicationListener 对象</span></span><br><span class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 推测出 main() 所在的类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行 SpringApplication 对象它的 run() 方法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    DefaultBootstrapContext bootstrapContext = <span class="keyword">this</span>.createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 从 spring.factories 中获取 SpringApplicationRunListener --&gt; EventPublishingRunListener</span></span><br><span class="line">    <span class="comment">// 会启动过程的各个阶段发布对应的事件</span></span><br><span class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">    listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 run 方法参数封装成 DefaultApplicationArguments 对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 根据应用类型创建 Spring 容器</span></span><br><span class="line">        context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">        <span class="keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 刷新 Spring 容器，解析配置类、扫描、启动 WebServer</span></span><br><span class="line">        <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">        Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup);</span><br><span class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var12, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">        listeners.ready(context, timeTakenToReady);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>archLinux 安装</title>
    <url>/blog.github.io/2021/12/28/archLinux-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文采用efi分区，因为厌烦了grub故换systemd-boot，桌面为bspwm，硬件为Intel cpu和amd gpu</p>
<h2 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h2><h3 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h3><p>ls /sys/firmware/efi/efivars</p>
<span id="more"></span>

<h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>iwctl </p>
<h3 id="检查是否联通"><a href="#检查是否联通" class="headerlink" title="检查是否联通"></a>检查是否联通</h3><p>ping -c 3 archlinux.org</p>
<h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><p>timedatectl set-ntp true </p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><pre><code>1. fidsk /dev/sda
2. g新建gpt分区表
3. n新建分区 ,类型序号开头都回车结尾定义空间大小，然后t改成efi
4. p查看完成的分区表，w保存退出
5. 自改分区如下
    1. sda1 +512M EFI
    2. sda2 +50G 
    3. sda3 余下
</code></pre>
<h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><pre><code>1.  mkfs.fat -F32 /dev/sda1
2.  mkfs.ext4 /dev/sda2
3.  mkfs.ext4 /dev/sda3
</code></pre>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><pre><code>1.  mount /dev/sda2  /mnt
2.  mkdir -p /mnt/boot &amp; mount /dev/sda1  /mnt/boot
3.  mkdir -p /mnt/home &amp; mount /dev/sda3  /mnt/home
</code></pre>
<h3 id="安装基本操作系统"><a href="#安装基本操作系统" class="headerlink" title="安装基本操作系统"></a>安装基本操作系统</h3><p>pacstrap /mnt base linux linux-firmware vim iwd </p>
<h3 id="配置挂载信息"><a href="#配置挂载信息" class="headerlink" title="配置挂载信息"></a>配置挂载信息</h3><p>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</p>
<h3 id="切换到安装到系统"><a href="#切换到安装到系统" class="headerlink" title="切换到安装到系统"></a>切换到安装到系统</h3><p>arch-chroot /mnt </p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><pre><code>1. ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
2. hwclock --systohc
</code></pre>
<h3 id="本地化编码"><a href="#本地化编码" class="headerlink" title="本地化编码"></a>本地化编码</h3><pre><code>1.  vim /etc/locale.gen，反注释zh_CN.UTF-8 UTF-8和us_EN.UTF-8
2.  locale-gen
3.  vim /etc/locale.conf 加入 LANG=en_US.UTF-8
</code></pre>
<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><pre><code>1. echo “shaka-arch” &gt;&gt; /etc/hostname
2. /etc/hosts 
    127.0.0.1   localhost
    ::1             localhost
    127.0.1.1   shaka-arch.localdomain  shaka-arch
</code></pre>
<h3 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h3><pre><code>1. passwd
2. useradd -m xxx 然后passwd xxx
</code></pre>
<h3 id="Intel微码"><a href="#Intel微码" class="headerlink" title="Intel微码"></a>Intel微码</h3><p>pacman -S intel-ucode</p>
<h3 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h3><pre><code>1.  bootctl --path=/boot$esp install
2.  vim /boot/loader/loader.conf （没有下面的序号）
    1. default arch #默认引导的系统，注意这里的 arch 对应的是 arch.conf
    2. timeout 1    #在引导界面停留的时间，如果你想引导不止一个系统，不应将这一项设置成0
    3. editor    0    #这将会禁用编辑内和参数的功能，默认是开启的，如果你的计算机可能被他人使用，将该功能关闭是推荐的选择
3. vim /boot/loader/entries/arch.conf
    1. title Arch Linux               #这是启动选项的名称，将会出现在引导界面
    2. linux   /vmlinuz-linux         #压缩的可引导内核，用于系统启动
    3. initrd  /intel-ucode.img       #由芯片制造商提供的对 CPU 微码的稳定性和安全性更新，按照 Arch wiki 的说法它应当是&#39; first initrd in the bootloader config file&#39;
    4. initrd  /initramfs-linux.img   #为内核提供的一个临时的文件系统
    5. options root=/dev/sdap2 rw     #/root 挂载的位置，可以由 LABEL, PARTUUID 或者 UUID识别，此处使用了块设备的路径
</code></pre>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>1.  systemctl enable systemd-networkd
2.  systemctl enable systemd-resolved
3.  systemctl enable systemd-timesyncd
4.  systemctl enable iwd
</code></pre>
<h3 id="加入sudoers"><a href="#加入sudoers" class="headerlink" title="加入sudoers"></a>加入sudoers</h3><p>pacman -S sudo 然后 EDITOR=vim visudo </p>
<h3 id="复制网络配置到新系统"><a href="#复制网络配置到新系统" class="headerlink" title="复制网络配置到新系统"></a>复制网络配置到新系统</h3><p>cp /etc/systemd/network/* /mnt/etc/systemd/network/ </p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>exit 然后 umount -R /mnt 接着reboot重启机器</p>
<h2 id="桌面bspwm"><a href="#桌面bspwm" class="headerlink" title="桌面bspwm"></a>桌面bspwm</h2><pre><code>1. sudo pacman -S xf86-video-amdgpu alsa alsa-utils显卡声卡驱动
2. alsamixer 调节音量
3. sudo pacman -S xorg 图形服务
4. sudo pacman -S bspwm sxhkd feh 
5. yay -S polybar 状态栏
6. 安装完成后需要在$HOME/.xinitrc中添加exec bspwm，然后通过startx即可启动。
7. 在家目录下分别新建文件夹 .config/bspwm   .config/sxhkd   .config/polybar用于存放对应配置，分别是bspwm，快捷键和polybar的基本配置文件，初始配置可从/usr/share/doc中获取
8. alacritty 终端模拟器 ranger 文件管理器 sxiv 图片浏览 rofi程序查找
9. 壁纸feh --bg-fill --randomize --recursive IMAGES_DIR_PATH 加入到bspwmrc配置文件
10. wqy-microhei中文字体
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>archLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 原理</title>
    <url>/blog.github.io/2022/04/26/Spring-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="IOC-过程"><a href="#IOC-过程" class="headerlink" title="IOC 过程"></a>IOC 过程</h3><blockquote>
<p>BeanFactory 为整个容器的根入口，也是容器的入口</p>
</blockquote>
<ol>
<li><p>解析配置文件，定义解析文件的规范 BeanDefinitionReader 接口方便扩展，解析为 BeanDefinition</p>
</li>
<li><p>使用 BeanFactoryPostProcessor 增强 BeanDefinition 信息</p>
</li>
<li><p>实例化（半成品），属性都是默认值</p>
</li>
<li><p>初始化:填充属性</p>
<ol>
<li><p>自定义属性 populateBean</p>
</li>
<li><p>容器属性 invokeAwareMethods</p>
</li>
<li><p>使用 BeanPostProcessor 增强 bean 信息（比如 AOP，AbstractAutoProxyCreator 动态代理），两个方法间中间执行初始化方法(init-method)</p>
</li>
</ol>
</li>
<li><p>使用</p>
</li>
</ol>
<h4 id="重要接口"><a href="#重要接口" class="headerlink" title="重要接口"></a>重要接口</h4><p>BeanFactory、BeanDefinitionReader、BeanDefinition、Aware、BeanFactoryPostProcessor、BeanPostProcessor、Environment、FactoryBean、BeanDefinitionRegistry</p>
<ol>
<li><p>ApplicationContext 与 BeanFactory 关系，和默认 BeanFactory</p>
<p> <img src="/blog.github.io/2022/04/26/Spring-%E5%8E%9F%E7%90%86/ApplicationContext.png"></p>
<p> <img src="/blog.github.io/2022/04/26/Spring-%E5%8E%9F%E7%90%86/DefaultListableBeanFactory.png"></p>
</li>
<li><p>BeanDefinition </p>
<p> <img src="/blog.github.io/2022/04/26/Spring-%E5%8E%9F%E7%90%86/RootBeanDefinition.png"></p>
</li>
<li><p>BeanFactoryPostProcessor 增强器，增强 BeanDefinition</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Factory hook that allows for custom modification of an application context&#x27;s</span></span><br><span class="line"><span class="comment">* bean definitions, adapting the bean property values of the context&#x27;s underlying</span></span><br><span class="line"><span class="comment">* bean factory.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">    * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">    * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">    * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <font color=orange>说明</font></p>
<p> PlaceholderConfigurerSupport 是其抽象子实现，可以替换 xml 配置文件中的占位符</p>
</li>
</ol>
<ol start="4">
<li><p>Aware</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 标志 bean 的容器属性赋值，由 spring 调用，Bean 应实现其子接口，如 ApplicationContextAware</span></span><br><span class="line"><span class="comment">* A marker superinterface indicating that a bean is eligible to be notified by the</span></span><br><span class="line"><span class="comment">* Spring container of a particular framework object through a callback-style method.</span></span><br><span class="line"><span class="comment">* The actual method signature is determined by individual subinterfaces but should</span></span><br><span class="line"><span class="comment">* typically consist of just one void-returning method that accepts a single argument.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Note that merely implementing &#123;<span class="doctag">@link</span> Aware&#125; provides no default functionality.</span></span><br><span class="line"><span class="comment">* Rather, processing must be done explicitly, for example in a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor&#125;.</span></span><br><span class="line"><span class="comment">* Refer to &#123;<span class="doctag">@link</span> org.springframework.context.support.ApplicationContextAwareProcessor&#125;</span></span><br><span class="line"><span class="comment">* for an example of processing specific &#123;<span class="doctag">@code</span> *Aware&#125; interface callbacks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BeanPostProcessor 可以扩展 Bean，比如 AOP、注解（@AutoWired、@Value、@AfterContruct）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AutoWired、@Value 注解的功能的完成，先有 XML 配置方式后来扩展的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">    <span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BeanFactory 和 FactoryBean 都是用来创建对象的，BeanFactory 必须遵循完整的创建过程，这个过程是由 Spring 来管理控制的，而 FactoryBean 只需要调用 getObject 就可以返回具体的对象，整个对象的创建过程是由客户自己控制的，更加灵活</p>
</li>
</ol>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><blockquote>
<p>6 个方法：getBean doGetBean createBean doCreateBean createBeanInstance populateBean</p>
</blockquote>
<p>三级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一级缓存 */</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 三级缓存 */</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 二级缓存 */</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><font color=orange>说明</font></p>
<p>按照 123 的顺序来获取对象，前面的缓存有就把后面的除掉。如果只有一级缓存，成品和半成品对象放到一起会覆盖掉，因此需要两个缓存分别放对象和半成品对象。Spring 无法预知是否需要代理对象，因此需要一个类似回调的方法 getEarlyBeanReference 放三级缓存中，需要代理对象时就覆盖原始对象并对外暴露代理对象</p>
<h3 id="AOP-过程"><a href="#AOP-过程" class="headerlink" title="AOP 过程"></a>AOP 过程</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 内存与垃圾回收</title>
    <url>/blog.github.io/2022/03/23/jvm/</url>
    <content><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote>
<p>此处只是基本介绍，关于加载篇 <a href="/blog.github.io/2022/03/29/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/#类的加载">请看</a></p>
</blockquote>
<p>类的加载分为三个阶段，即加载、链接和初始化</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>引导类加载器</p>
<p> c/c++ 语言编写，无法获取，用于加载java的核心类库</p>
</li>
<li><p>扩展类加载器</p>
<p> 加载 java.ext.dirs 系统路径所指定的类库，自己的应用放在其中也可以由扩展类加载器加载</p>
</li>
<li><p>系统类加载器</p>
<p> 加载自己的 java 应用程序</p>
</li>
<li><p>自定义类加载器</p>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>java虚拟机对 class 文件的加载是按需加载，收到加载请求先由父加载器加载，加载失败则由子加载器加载</p>
<p>判断 Class 是否为同一个，则需要全限定类名和类加载器都相同</p>
<p>优势</p>
<ol>
<li><p>防止重复加载</p>
</li>
<li><p>防止核心 API 被篡改</p>
</li>
</ol>
<h2 id="内存与垃圾回收篇"><a href="#内存与垃圾回收篇" class="headerlink" title="内存与垃圾回收篇"></a>内存与垃圾回收篇</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>图示</p>
<p><img src="/blog.github.io/2022/03/23/jvm/1.png"></p>
<p>上图红色的共享，灰色的每个线程独有</p>
<h3 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h3><p>用来存储 java 指令的地址，运行速度快且不会内存溢出</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>运行速度仅次于 PC 寄存器，基本单位为栈帧，设置栈大小 Xss</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>内部结构：<code>局部变量表</code>、<code>操作数栈</code>、动态链接、方法返回地址、一些附加信息</p>
<ol>
<li><p>局部变量表</p>
<p> 基本单位为 slot，存放基本数据类型和引用，long 和 double 占两个 slot，非静态方法的第一个变量为 this，其他按声明顺序排序，且一旦销毁可以重用</p>
<p> 类变量在链接的 prepare 阶段默认赋值，在初始化阶段显式赋值和静态代码块赋值</p>
<p> 实例变量随着对象的创建在堆空间赋值</p>
<p> 局部变量必须显式赋值</p>
</li>
<li><p>操作数栈</p>
<p> 根据字节码指令往操作数栈中存取数据，主要用来保存计算过程中的中间结果，同时作为计算过程变量的临时保存空间，刚有栈帧时操作数栈是空的，但最大深度在编译器就定义好了</p>
</li>
</ol>
<ol start="3">
<li><p>动态链接</p>
<p> 指向运行时常量池的方法的引用</p>
</li>
<li><p>方法的调用</p>
<p> 早起绑定（编译期确定）和晚期绑定（运行期确定/多态）</p>
<p> 非虚方法：静态方法、私有方法、final 方法、实例构造器、父类方法</p>
<p> 虚方法：其他方法</p>
<p> 在类加载的链接阶段为了提高性能会创建一个虚方法表，已经重写的用自己的，没重写的记录下来不必一层层向上找</p>
</li>
<li><p>方法返回地址</p>
<p> 存放调用该方法的 PC 寄存器的值</p>
</li>
<li><p>栈帧附加信息</p>
</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>有时 java 应用需要与外部环境交互，这是本地方法存在的主要原因，本地方法栈并非所有虚拟机都有</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一个进程一个 jvm 实例，一个 jvm 实例一个运行时数据区，一个堆区，一个进程多个线程，一个线程一个栈、一个 pc 寄存器、一个本地方法栈，堆(除了TLAB)和方法区多个线程共享，堆是 GC 的重点</p>
<h3 id="堆的细分"><a href="#堆的细分" class="headerlink" title="堆的细分"></a>堆的细分</h3><p>jdk7 及以前分为新生代、老年代和永久代（逻辑上）</p>
<p>jdk8 以后分为新生代、老年代和元空间（逻辑上）</p>
<p>新生代分为伊甸园区和幸存者区</p>
<p>Xms 设置初始（新生代 + 老年代）大小， Xmx 设置最大（新生代 + 老年代）值，-XX:NewRatio 配置新生代与老年代占比，-XX: SurvivorRatio 配置伊甸园区与幸存者区占比</p>
<p>对象不一定创建在堆中，可以开启逃逸分析开启栈上分配</p>
<h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><ul>
<li><p>新对象优先放伊甸园区</p>
</li>
<li><p>当伊甸园区空间满了又需要放入新对象，则进行 young GC/Minor GC，将不再需要的垃圾回收，再把新对象放入伊甸园区，将剩余的放入幸存者区</p>
</li>
<li><p>当伊甸园区再次满了，则再次垃圾回收将没回收的对象放入另一块幸存者区，同时将原来的幸存者区的对象也放入这块幸存者区</p>
</li>
<li><p>当幸存者区对象的年龄达到阈值值提升进老年代，默认15</p>
</li>
<li><p>当伊甸园区满了才会 young GC/Minor GC，幸存者区满了不会触发 young GC/Minor GC，但幸存者区的无用对象在 young GC/Minor GC  的时候也会被回收</p>
</li>
<li><p>大部分对象朝生夕死，在 young GC/Minor GC 就被回收掉了</p>
</li>
<li><p>如果新对象新生代 young GC 后还放不下则直接准备放进老年代，如果老年代放不下进行 Major GC，Major GC 之后放得下放进老年代，放不下则 OOM</p>
</li>
<li><p>当 young GC 时幸存者区放不下伊甸园区来的对象则放进老年代</p>
</li>
<li><p>young GC 会清空伊甸园区</p>
</li>
<li><p>TLAB 是在伊甸园区为每个线程创建的一小块区域，为线程私有，空间很小，无线程安全问题，对象优先分配在 TLAB 空间</p>
</li>
<li><p>栈上分配 &gt; TLAB 上分配 &gt; eden 区 &gt; 老年代创建对象，其中栈上分配和 TLAB 分配考虑到逃逸分析所以无线程安全问题</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于储存已经加载的类信息、运行时常量池、静态变量、JIT 代码缓存等</p>
<p>Hotspot 方法区的变化：</p>
<p><img src="/blog.github.io/2022/03/23/jvm/2.png"></p>
<hr>
<p>为什么去永久代？</p>
<ol>
<li><p>永久代大小很难确定，小了容易 Full GC 造成 STW，大了造成浪费</p>
</li>
<li><p>永久代调优困难</p>
</li>
</ol>
<hr>
<p>为什么 StringTable 换位置？</p>
<p>放在堆里回收效率更高</p>
<hr>
<p>方法区的垃圾回收主要针对类的卸载和常量池，不同虚拟机不一定都有方法区的回收</p>
<h3 id="对象的实例化、内存布局及访问定位"><a href="#对象的实例化、内存布局及访问定位" class="headerlink" title="对象的实例化、内存布局及访问定位"></a>对象的实例化、内存布局及访问定位</h3><p>对象实例化的几种方式：new、反射、反序列化、clone、第三方库</p>
<p>对象的创建步骤：</p>
<ol>
<li><p>对象对应的类是否加载、链接、初始化</p>
</li>
<li><p>为对象分配内存</p>
</li>
<li><p>处理并发安全问题</p>
</li>
<li><p>初始化分配到的空间/默认初始化</p>
</li>
<li><p>设置对象头</p>
</li>
<li><p>执行 Init 方法的初始化</p>
</li>
</ol>
<p>对象的内存布局：</p>
<ol>
<li><p>对象头</p>
<ul>
<li><p>运行时元数据</p>
<ul>
<li><p>哈希值</p>
</li>
<li><p>GC 分代年龄</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程ID</p>
</li>
<li><p>偏向线程时间戳</p>
</li>
</ul>
</li>
<li><p>类型指针</p>
</li>
<li><p>如果是数组，还得记录数组长度</p>
</li>
</ul>
</li>
<li><p>实例数据</p>
</li>
<li><p>对齐填充</p>
</li>
</ol>
<p>对象的访问主要有句柄访问和直接访问</p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>解释器：响应速度快</p>
<p>JIT编译器：效率高</p>
<p>jvm 启动时解释器首先发挥作用，无需等待编译器全部编译完成再执行，省却不必要的编译时间，随着时间推移，编译器发挥作用，越来越多的代码被编译成本地代码，获得更高的执行效率</p>
<p>一个被多次调用的方法，或者一个方法体内部循环次数较多的循环体被称作「热点代码」，可以通过 JIT 编译为本地代码，由于编译发生在方法执行过程中，因此被称为栈上替换(OSR)</p>
<p>HotSpot 采用方法调用计数器和回边计数器判定热点代码</p>
<p>方法调用计数器 Server 模式(64 位系统默认)下阈值为 10000，Client 模式下为 1500，如果超过一定时间仍不足以达到阈值，则会进入半衰期，半衰回收发生在 GC 时</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>JDK1.8 以前用 char 数组，9 以后用 byte 数组，因为大部分情况下都是拉丁字符，为了省空间改为 byte，为了兼容中文等字符，加上编码标记</p>
<p>String 不可变</p>
<p>字符串常量池不会存储相同的字符串，是一个固定大小的 HashTable</p>
<p>拼接操作：</p>
<pre><code>字符串常量与字符串常量拼接结果在字符串常量池，原因是编译期优化

出现变量相当于堆中 new String()

intern() 判断常量池中是否存在，存在返回地址，否则加载一份并返回地址
</code></pre>
<h3 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h3><p>垃圾回收针对<code>堆</code>和方法区，程序计数器没有 GC 没有溢出，栈和本地方法栈没有 GC 有 StackOverFlow</p>
<h4 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h4><p><code>引用计数算法</code></p>
<p>使用引用计数器</p>
<p>优点：简单便于标识，效率比较高，回收没有延迟</p>
<p>缺点: 增加储存空间和计数开销，最糟糕的是无法处理循环引用，因此 Java 不用该算法</p>
<p><code>可达性分析算法</code></p>
<p>直接或间接连接 GC Roots</p>
<p>GC Roots:</p>
<ul>
<li><p>栈引用的对象</p>
</li>
<li><p>本地方法引用的对象</p>
</li>
<li><p>静态属性、常量引用的对象</p>
</li>
<li><p>被同步锁持有的对象</p>
</li>
<li><p>Java 虚拟机内部引用</p>
</li>
</ul>
<h4 id="清除算法"><a href="#清除算法" class="headerlink" title="清除算法"></a>清除算法</h4><p><code>标记清除算法</code></p>
<p>从根对象标记所有可达对象，然后线性遍历堆中所有对象删除不可达对象</p>
<p>缺点：效率低、碎片化</p>
<p><code>复制算法</code></p>
<p>使用两块空间，每次只使用一块，然后把可达对象复制到另一块空间，需要复制的对象越少越好，例如新生代朝生夕死</p>
<p>优点：高效、无碎片化</p>
<p>缺点：需要两倍空间、需要维护引用关系</p>
<p><code>标记压缩算法</code></p>
<p>标记所有被引用对象，然后移动到内存的一端清除其他</p>
<p>优点：消除了标记清除算法的碎片化和复制算法的 2 倍空间浪费</p>
<p>缺点：效率不如复制算法，移动时需要调整引用位置</p>
<p><code>分代收集算法</code></p>
<p>新生代对象生命周期短，存活率低、回收频繁，用复制算法，空间浪费用两块幸存者区补偿，老年代空间大、对象大、存活率高、生命周期长回收频率又低适合标记清除和标记压缩的混合实现</p>
<p><code>增量收集算法</code></p>
<p>通过对线程间线程的妥善处理，允许垃圾收集器以分阶段的方式完成标记、清除或复制工作，每次只收集一小片区域的内存空间，接着切换到应有程序线程，直到收集完成。这种方法的优势是能够减少系统的停顿时间，延迟低，但是因为线程上下文的切换会造成垃圾回收的整体成本上升，造成系统吞吐量的下降</p>
<p><code>分区算法</code></p>
<p>把堆空间分成多个小块（每个小块属于不同的代），根据目标停顿时间，每次合理回收若干小区，从而减少一次 GC 的停顿时间，降低延迟</p>
<h3 id="垃圾回收相关"><a href="#垃圾回收相关" class="headerlink" title="垃圾回收相关"></a>垃圾回收相关</h3><p>System.gc() 不一定马上调用垃圾回收</p>
<p>严格来说只有对象不被用到又无法 GC 才算内存泄露，内存泄露有可能导致内存溢出</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>强引用</code></p>
<p>传统的引用，只要引用关系在就不会被回收，强引用是造成内存泄露的主要原因之一</p>
<p><code>软引用</code></p>
<p>在内存溢出之前列入回收范围之内进行第二次回收，如果回收完还是不够则内存溢出，即内存不够则回收，典型应用场景比如高速缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftReference = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User(<span class="string">&quot;shaka&quot;</span>, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<p><code>弱引用</code></p>
<p>只能生存到下一次垃圾回收之前，当 GC 工作时无论是否引用都会被回收，即发现即回收</p>
<p><code>虚引用</code></p>
<p>对其生存没影响也不能通过引用获得对象，唯一目的是回收时收到一个系统通知</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><code>评估 GC 的性能指标：</code></p>
<ol>
<li><p><font color=red>吞吐量</font>，用户代码运行时间占总时间的比例</p>
</li>
<li><p>垃圾收集开销，吞吐量的补数，垃圾回收时间占总时间的比例</p>
</li>
<li><p><font color=red>暂停时间</font>，即 STW</p>
</li>
<li><p>收集频率，收集操作发生的频率</p>
</li>
<li><p><font color=red>内存占用</font>，Java 堆区所占内存大小</p>
</li>
<li><p>快速，从诞生到回收所经历时间</p>
</li>
</ol>
<p>随着硬件性能的提升有助于降低收集器运行时对性能的影响，即提高了吞吐量，同时对内存的占用越来越能够容忍，但是内存的提升却为 STW 带来负面影响，因此<font color=red>暂停时间</font>重要性日益凸显</p>
<p><code>常见垃圾回收器</code></p>
<p>串行：Serial、Serial Old</p>
<p>并行：ParNew、Parallel Scavenge、Parallel Old</p>
<p>并发：CMS、G1</p>
<p>七款经典垃圾回收器与堆内存分代关系：</p>
<p><img src="/blog.github.io/2022/03/23/jvm/3.png"></p>
<p>新生代垃圾回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代垃圾回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆垃圾回收器：G1</p>
<h4 id="Serial-与-Serial-Old"><a href="#Serial-与-Serial-Old" class="headerlink" title="Serial 与 Serial Old"></a>Serial 与 Serial Old</h4><p>Serial 使用复制算法、STW、穿行回收新生代</p>
<p>Serial Old 使用标记压缩算法、STW、穿行回收老年代</p>
<p>Serial 与 Serial Old 是 Hotspot 虚拟机 Client 模式下默认的垃圾回收器</p>
<h4 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h4><p>是 Serial 的多线程版本的新时代垃圾回收器，是很多垃圾回收器 Server 模式下的默认垃圾回收器</p>
<h4 id="Parallel-Scavenge-和-Parallel-Old"><a href="#Parallel-Scavenge-和-Parallel-Old" class="headerlink" title="Parallel Scavenge 和 Parallel Old"></a>Parallel Scavenge 和 Parallel Old</h4><p>Parallel Scavenge 和 Parnew 差不多，不过以吞吐量为优先，达到一个可控制的吞吐量，高吞吐量可以更多的利用 CPU，适合后台运行不需要多少交互的场景</p>
<p>Parallel Old 是采用标记压缩算法、并行回收的老年代垃圾回收器</p>
<p>Parallel Scavenge 和 Parallel Old 是 JDK8 默认的垃圾回收器</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>主打低延迟，采用标记清除算法，同样也有 STW ，第一次实现了并发的GC，执行步骤为串行初始标记、并发标记、并行重新标记、并发清除，由于耗时时间长的并发标记阶段和并发清除阶段都是并发的，因此 STW 时间相对较短，实现了低延迟。由于清除阶段用户线程没有中断，这时要保证用户线程有足够的空间，因此不能像其他垃圾回收器一样等到老年代完全填满了再进行回收，而是达到一定比例就需要回收，如果预留内存不过就要切换 Serial Old，这时 STW 就很长了</p>
<p><code>弊端：</code></p>
<p>标记清除造成的内存碎片，并发阶段造成吞吐量降低，并发标记阶段的新垃圾也不能及时清理需要等到下一次 GC</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>区域化分代式垃圾回收器，把堆内存分割成很多不同的 Region（逻辑上分代并且每个区属于哪个代不固定，并且多个 Humongous用来储存超过 1.5 个 Region 的大对象），有计划地在整个堆中避免全区域垃圾回收，跟踪不同 Region 的垃圾堆积的价值大小，优先回收价值大的 Region，主要针对多核心 CPU 和大容量内存的服务器，兼顾减少 STW 和提高吞吐量，是 JDK9 以后默认的回收器。</p>
<p><code>特点：</code></p>
<ol>
<li><p>并行与并发</p>
</li>
<li><p>分代收集</p>
</li>
<li><p>可预测的停顿时间模型</p>
</li>
<li><p>空间整合</p>
</li>
</ol>
<p><code>回收过程</code></p>
<ol>
<li><p>年轻代回收，首先 STW，创建回收集（需要被回收的内存分段的集合），复制算法回收伊甸园区和幸存者区</p>
</li>
<li><p>老年代标记 + 年轻代回收，初始标记 -&gt; 根区域扫描 -&gt; 并发标记 -&gt; 再次标记 -&gt; 独占清理 -&gt; 并发清理</p>
</li>
<li><p>混合回收,回收年轻代和一部分的老年代，垃圾占分段比例越高的越先被回收</p>
</li>
<li><p>Full GC</p>
</li>
</ol>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>区域化不设分代的垃圾回收器，使用读屏障、染色指针、内存多重映射实现可并发的标记压缩，主打低延迟，除了初始标记 STW，其他都并发执行，停顿时间非常短</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3</title>
    <url>/blog.github.io/2022/02/21/vue3/</url>
    <content><![CDATA[<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p><a href="https://cn.vitejs.dev/">新一代构建工具</a></p>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>组合式api,数据、方法等都要配置在setup函数中，并且必须返回，响应式基本数据类型、对象类型用ref，对象类型用reactive</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = ref(<span class="string">&#x27;shaka&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> tom = reactive(&#123;<span class="attr">uname</span>:<span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name.value);</span><br><span class="line">    tom.age = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(tom)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    say,</span><br><span class="line">    tom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>setup仅在beforeCreated执行一次，且this为undefined</p>
<p>props父组件向子组件传参,context上下文对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.p1);</span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> lastName = <span class="string">&#x27;jerry&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      firstName,</span><br><span class="line">      lastName,</span><br><span class="line">      fullName,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监视</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;TestVue3&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;p1&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = ref(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      a.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    watch(a,<span class="function">(<span class="params">newValue,oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a的值变了&#x27;</span>,newValue,oldValue)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      add,</span><br><span class="line">      a</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合</title>
    <url>/blog.github.io/2022/05/16/Java-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>Java 集合个人查漏补缺</p>
</blockquote>
<h3 id="简略结构"><a href="#简略结构" class="headerlink" title="简略结构"></a>简略结构</h3><p><img src="/blog.github.io/2022/05/16/Java-%E9%9B%86%E5%90%88/Collection.png" alt="Collection"></p>
<p><img src="/blog.github.io/2022/05/16/Java-%E9%9B%86%E5%90%88/Map.png" alt="Map"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Iterator 仅用于遍历集合，并不存放对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 指针向下移并返回元素，next() 之前必须 hasNext()，否则报错</span></span><br><span class="line">        <span class="comment">// 增强 for 即是简化版的迭代器</span></span><br><span class="line">        String s = iterator.next();</span><br><span class="line">        log.debug(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote>
<p>有序（添加顺序和取出顺序一致）可重复，支持索引</p>
</blockquote>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList 内部维护了一个 Object 的数组，如果使用的是无参构造器则初始化容量为 0，第一次添加扩容为 10，再次扩容为 1.5 倍，若使用指定大小的构造器，则初始化容量为指定大小，再次扩容为 1.5 倍</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector 的底层也是 Object 数组并且线程安全（synchorized，效率不高）</p>
<p>Vector 的扩容机制类似 ArrayList，不过是按 2 倍扩容</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>底层实现了双向链表和双端队列的特点，添加和删除的效率比较高，ArrayList 的改查效率高</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p>无序不可重复，没有索引</p>
</blockquote>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>实际上是 HashMap，底层为（数组 + 链表 + 红黑树），可以有 null 但只能有一个</p>
<p>add 步骤</p>
<ol>
<li><p>得到 hash 值(不是 hashCode 值)，转为索引</p>
</li>
<li><p>找到存储数据表 table(数组),如果索引位置无元素则直接放入，有元素则调用 equals 比较，相同放弃添加，不同添加到链表最后</p>
</li>
<li><p>第一次添加时 table 数组扩容到 16，临界值 16 * 0.75 = 12，当 table 数组达到临界则扩容为 32，临界 32 * 0.75 = 24，以此类推</p>
</li>
<li><p>java8 中如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认 8)，并且 table 大小超过 MIN_TREEIFY_CAPACITY(默认 64) 则树化</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果当前 table 为null 或者大小为 0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// table 是 HashMap 的一个 Node 类型数组，初始扩容大小为 16，临界 12</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 key 得到 hash 值，并计算 key 应该存放的索引位置，并把 p 指向该位置对象</span></span><br><span class="line">    <span class="comment">// 如 p 为 null 则新建 Node 节点   </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果新加入的元素 hash 值和当前位置的hash 值一样，并且为同一个对象或者内容相同，则不添加</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否是红黑树    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果和链表的每一个元素比较后都不相同就放到链表最后，有相同的则 break</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否需要树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 看是否临界</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>底层为 LinkedHashMap，维护了一个数组和双向链表，可以保证插入顺序和取出顺序一致</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashTable 的 key value 都不能为 null, 线程安全（synchronized），底层数组默认大小 11，加载因子 0.75，TreeMap 和 TreeSet 可以排序，TreeSet 底层为 TreeMap</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 相关</title>
    <url>/blog.github.io/2022/05/26/Redis-%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>fork 子线程来备份数据，主线程有写如操作时利用 copy on write 另外复制一份内存数据拷贝，写操作在拷贝的数据上进行</p>
<p>缺点： 容易丢数据， CPU及内存消耗高</p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>命令备份</p>
<p>缺点：备份恢复慢，文件体积大</p>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p>redis 的读操作一般较多因此使用一主多从架构</p>
<h4 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h4><p><img src="/blog.github.io/2022/05/26/Redis-%E7%9B%B8%E5%85%B3/1.png" alt="全量同步"></p>
<ol>
<li><p>从节点发起增量同步请求</p>
</li>
<li><p>主节点查看从节点的 replid 是否和自己一致，不一致拒绝增量同步</p>
</li>
<li><p>主节点生成 RDB 并发送到从节点</p>
</li>
<li><p>子节点清空本地数据加载主节点 RDB</p>
</li>
<li><p>主节点将 RDB 期间的命令记录在 repl_bakLog 并持续将 log 发给子节点</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
